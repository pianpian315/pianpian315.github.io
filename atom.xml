<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pianpian315.github.io</id>
    <title>Pianpian&apos;s Blog</title>
    <updated>2019-11-25T00:12:19.729Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pianpian315.github.io"/>
    <link rel="self" href="https://pianpian315.github.io/atom.xml"/>
    <subtitle>不积跬步，无以至千里</subtitle>
    <logo>https://pianpian315.github.io/images/avatar.png</logo>
    <icon>https://pianpian315.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Pianpian&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java中synchronized实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li">
        </link>
        <updated>2019-11-20T14:15:47.000Z</updated>
        <content type="html"><![CDATA[<p>理解synchronized实现原理，需要弄清楚以下几点：</p>
<h3 id="1-java对象的组成">1、Java对象的组成</h3>
<p>在JVM中，每个Java对象由三部分组成：对象头、实例数据和对齐填充。</p>
<p>Java对象头：普通对象的对象头包括两部分：Mark Word 和 Class Metadata Address （类型指针），如果是数组对象还包括一个额外的Array length数组长度部分。<br>
实例变量：存放类的属性数据信息。<br>
填充数据：虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>这里，我们需要重点说说Java对象头。</p>
<h3 id="2-java对象头与锁的关系">2、Java对象头与锁的关系</h3>
<p>前面说过，Java对象头主要结构是由Mark Word 和 Class Metadata Address 组成。</p>
<p>对象头对应的内容在oopDesc里面，在hotspot源码 oop.hpp中对oopDesc进行了定义，定义如下：</p>
<pre><code>class oopDesc {
  friend class VMStructs;

 private:
  volatile markOop  _mark; // 对应Mark Word

  union _metadata {   // 对应Class Metadata Address
    Klass*      _klass;
    narrowKlass _compressed_klass;
  } _metadata;
}
</code></pre>
<p>Mark Word：存储对象自身的运行时数据，如对象的hashCode、锁信息或分代年龄或GC标志等信息。<br>
Class Metadata Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</p>
<p>这里需要重点说到的就是Mark Word，也就是上面的markOop，在Hotspot中，它的定义markOop.hpp文件中，代码如下：</p>
<pre><code>class markOopDesc: public oopDesc {

 private:
  // Conversion
  uintptr_t value() const { return (uintptr_t) this; }

 public:
  // Constants
  enum { age_bits                 = 4,  //分代年龄
         lock_bits                = 2, //锁标识
         biased_lock_bits         = 1, //是否为偏向锁
         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,
         hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits, //对象的hashcode
         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),
         epoch_bits               = 2 //偏向锁的时间戳
  };

...
</code></pre>
<p>从上面我们可以大致的看到Mark Word里面的存储内容，Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，下面以32位虚拟机为例。<br>
<img src="https://pianpian315.github.io/post-images/1574640692885.png" alt=""></p>
<p>可以看到Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，其实围绕这个锁的一系列操作都和Mark word有关系。</p>
<p>在JDK1.6之前，synchronized是一个重量级锁，从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，synchronized进行了优化，引入了 偏向锁和轻量级锁的概念。所以从JDK1.6开始，锁的状态根据竞争激烈程度从低到高分别是:无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。锁的状态会随着锁竞争的情况逐步升级，另外，为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。</p>
<h4 id="偏向锁">偏向锁</h4>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p>对于锁竞争比较激烈的场合，也就是每次申请锁的线程都是不相同的，这个时候偏向锁失败，此时Mark Word 的结构也变为轻量级锁的结构。引入轻量级锁的目的是在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗。</p>
<h4 id="重量级锁">重量级锁</h4>
<p>如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，重量级锁就是通过对象内部的监视器（monitor）实现。</p>
<p>markOopDesc里面扩展了自己的monitor方法，这个方法返回一个ObjectMonitor指针对象，在hotspot虚拟机中，就是使用这个ObjectMonitor类来实现monitor的。</p>
<pre><code>bool has_monitor() const {
  return ((value() &amp; monitor_value) != 0);
}

ObjectMonitor* monitor() const {
  assert(has_monitor(), &quot;check&quot;);

  // Use xor instead of &amp;~ to provide one extra tag-bit check.
  return (ObjectMonitor*) (value() ^ monitor_value);
}
</code></pre>
<p>在 ObjectMonitor.hpp中，可以看到ObjectMonitor的定义：</p>
<pre><code>class ObjectMonitor {
    ...

    ObjectMonitor() {
    _header       = NULL; //markOop对象头
    _count        = 0;    
    _waiters      = 0,   //等待线程数
    _recursions   = 0;   //重入次数
    _object       = NULL;  
    _owner        = NULL;  //获得ObjectMonitor对象的线程
    _WaitSet      = NULL;  //处于wait状态的线程，会被加入到waitSet
    _WaitSetLock  = 0 ; 
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁BLOCKED状态的线程
    _SpinFreq     = 0 ;   
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ; 
    _previous_owner_tid = 0; //监视器前一个拥有线程的ID
    }
    ...
}
</code></pre>
<p>在这里，我们可以知道每个对象都有一个monitor与之关联，monitor可以理解为一个对象监视器，这个对象监视器作为一个同步工具来记录和确保代码的同步性。</p>
<p>大致流程如下：</p>
<p>oopDesc–&gt;markOopDesc–方法monitor()–&gt;ObjectMonitor–&gt;enter、exit 获取、释放锁</p>
<p>当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。</p>
<p>若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：<br>
<img src="https://pianpian315.github.io/post-images/1574640708722.png" alt=""></p>
<h3 id="3-synchronized字节码">3、synchronized字节码</h3>
<p>下面从字节码入手，来看看synchronized作为实例锁的两种用法。</p>
<pre><code>public class App {
    public synchronized void test1() {
    }

    public void test2() {
        synchronized (this){
        }
    }

    public static void main( String[] args ){
        System.out.println( &quot;Hello World!&quot; );
    }
}
</code></pre>
<p>通过 javap -v App.class查看字节码。</p>
<pre><code>public synchronized void test1();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 同步修饰符
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  this   Lcom/gupaoedu/openclass/App;


  public void test2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter  //监视器进入，获取锁
         4: aload_1
         5: monitorexit  //监视器退出，释放锁
         6: goto          14
         9: astore_2
        10: aload_1
        11: monitorexit
        12: aload_2
        13: athrow
        14: return
</code></pre>
<p>同步块的实现使用monitorenter和monitorexit指令，而同步方法是依靠方法修饰符上的flag ACC_SYNCHRONIZED来完成。其本质就是通过锁对象头中的Mark word来实现的。</p>
<h3 id="参考文献">参考文献：</h3>
<p>https://blog.csdn.net/javazejian/article/details/72828483<br>
https://juejin.im/post/5b90cd7c5188255c877e20c8<br>
https://www.jianshu.com/p/c5058b6fe8e5<br>
https://www.cnblogs.com/dennyzhangdd/p/6734638.html<br>
https://tech.meituan.com/2018/11/15/java-lock.html<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483689&amp;idx=1&amp;sn=4bd727cc4991e54e273e099010c82d3b&amp;chksm=e96eaae7de1923f14db6ab744331c5f3ea1176af0cfd16df598f9e8817f2e4512dae6dd17d16&amp;token=860755966&amp;lang=zh_CN&amp;scene=21#wechat_redirect<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483699&amp;idx=1&amp;sn=9e51113bbbb3ae94d6b7273f3ee1b00f&amp;chksm=e96eaafdde1923eb6d3f721c902335c54037b503d5a3d7693e30246efa8356c41ea17bcfacc5&amp;token=1402731013&amp;lang=zh_CN#rd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的VSync机制]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi">
        </link>
        <updated>2019-11-10T06:42:05.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道，UI的显示是一帧一帧的，一次绘制过程，我们称其为一帧，在Flutter中，engine是通过VSync信号不断地触发每一帧的绘制，我们之所以说Flutter可以实现60fps，就是因为一秒钟可以触发60次重绘，那绘制是如何通过VSync信号进行驱动的呢？<br>
<img src="https://pianpian315.github.io/post-images/1573368494773.png" alt=""></p>
<p>VSync可以理解为一种定时中断，系统在每次可以进行绘制的时候都会发送VSync信号，CPU/GPU收到信号后马上处理绘制。所以，在Flutter中，当需要进行渲染绘制的时候，我们就需要监听VSync信号，当有VSync信号产生的时候，就可以绘制操作。<br>
<img src="https://pianpian315.github.io/post-images/1573368549589.png" alt=""></p>
<p>那现在的问题就是如果需要进行绘制操作，如何来监听这个VSync信号呢？我们首先需要通过引擎Engine的ScheduleFrame()方法来注册VSYNC信号回调，这个时候当Vsync信号到来的时候就会收到通知，然后就可以进行渲染绘制操作了。</p>
<p>ScheduleFrame()是Flutter Engine里面的方法，我们在Flutter Framework中如何调用到这个方法了，这个时候上一篇文章讲解的Window就发挥出作用了，在Window中有一个native的scheduleFrame方法，它调用的就是引擎Engine的ScheduleFrame()方法，跟Java中的JNI机制差不多，注册完成之后，当下一个VSync信息到来的时候，Window类中的_handleBeginFrame()和_handleDrawFrame()就会被回调，这样我们就可以收到绘制通知，具体的源码调用过程这里就不展开了，感兴趣的可以参考文章：http://gityuan.com/2019/06/15/flutter_ui_draw/。</p>
<p>下面我们同样举个例子来验证一下这个监听和回调过程：</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onBeginFrame = (Duration rawTimeStamp) {
    print(&quot;onBeginFrame: &quot; + rawTimeStamp.toString());
  };

  window.onDrawFrame = () {
    print(&quot;onDrawFrame&quot;);
  };

  print(&quot;scheduleFrame&quot;);
  window.scheduleFrame();
}
</code></pre>
<p>上面的代码很简单，首先实现了onBeginFrame和onDrawFrame回调，然后调用window的scheduleFrame注册VSync监听。</p>
<p>运行该程序，输出结果如下：</p>
<pre><code>I/flutter ( 4296): scheduleFrame
I/flutter ( 4296): onBeginFrame: 281:12:30.761601
I/flutter ( 4296): onDrawFrame
</code></pre>
<p>其实在Flutter Framework中，UI的渲染就是通过监听这个来触发的，Flutter Framework对其进行了封装，通过一个渲染流水线（Rendering pipline）来进行UI的渲染，具体我们在SchedulerBinding类中的initInstances方法中可以看到。</p>
<pre><code class="language-dart">mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onBeginFrame = _handleBeginFrame;
    window.onDrawFrame = _handleDrawFrame;
    
    // ......
  }

  void _handleBeginFrame(Duration rawTimeStamp) {
    if (_warmUpFrame) {
      assert(!_ignoreNextEngineDrawFrame);
      _ignoreNextEngineDrawFrame = true;
      return;
    }
    handleBeginFrame(rawTimeStamp);
  }

  void _handleDrawFrame() {
    if (_ignoreNextEngineDrawFrame) {
      _ignoreNextEngineDrawFrame = false;
      return;
    }
    handleDrawFrame();
  }
  
  // ......
}
</code></pre>
<p>上面的代码涉及到渲染的整个流水线过程，这里就不进行展开，后面会专门进行分析，这里需要重点理解的是整个Vsync机制，它是UI绘制的发动机，通过它的驱动UI才能不断的进行绘制。</p>
<h3 id="参考文章">参考文章</h3>
<p>https://juejin.im/post/5b7767fef265da43803bdc65<br>
http://gityuan.com/2019/06/15/flutter_ui_draw/<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html<br>
https://www.jianshu.com/p/a9364f778bf8<br>
https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://coolegos.github.io/2017/10/18/Andorid%E4%B8%ADVSync%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的Window]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-window</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-window">
        </link>
        <updated>2019-11-10T06:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>在Flutter中，Window类是Flutter Framework跟宿主系统相连接的接口，宿主系统通过Window类开放了各种各样的回调方法以及native调用接口供Flutter Framework使用。Window类来自库dart:ui，相关源代码在window.dart中，我们来具体看看其代码。</p>
<pre><code class="language-dart">/// The [Window] singleton. This object exposes the size of the display, the
/// core scheduler API, the input event callback, the graphics drawing API, and
/// other such core services.
final Window window = new Window._();
</code></pre>
<p>上面代码是Window实例化的过程，从注释我们可以知道，Window是一个单例对象，它对上层提供屏幕尺寸，调度接口，输入事件回调，图形绘制接口以及其他一些核心服务。正是因为如此，我们才可以通过window来获取底层系统传递过来的各种各样的信息，另外，window也提供了一些native调用，方便上层进行一些系统调用。</p>
<p>下面来具体看看核心代码：</p>
<pre><code class="language-dart">class Window {

  // 当前设备的DPI，即一个逻辑像素显示多少物理像素，数字越大，显示效果就越精细保真。
  // DPI是设备屏幕的固件属性，如Nexus 6的屏幕DPI为3.5 
  double get devicePixelRatio =&gt; _devicePixelRatio;

  // Flutter UI绘制区域的大小
  Size get physicalSize =&gt; _physicalSize;

  // 当前系统默认的语言Locale
  Locale get locale;

  // 当前系统字体缩放比例。  
  double get textScaleFactor =&gt; _textScaleFactor;  

  // 当绘制区域大小改变回调
  VoidCallback get onMetricsChanged =&gt; _onMetricsChanged;  
  // Locale发生变化回调
  VoidCallback get onLocaleChanged =&gt; _onLocaleChanged;
  // 系统字体缩放变化回调
  VoidCallback get onTextScaleFactorChanged =&gt; _onTextScaleFactorChanged;
  // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用
  FrameCallback get onBeginFrame =&gt; _onBeginFrame;
  // 绘制回调  
  VoidCallback get onDrawFrame =&gt; _onDrawFrame;
  // 点击或指针事件回调
  PointerDataPacketCallback get onPointerDataPacket =&gt; _onPointerDataPacket;
  // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用，
  // 此方法会直接调用Flutter engine的Window_scheduleFrame方法
  void scheduleFrame() native 'Window_scheduleFrame';
  // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法
  void render(Scene scene) native 'Window_render';

  // 发送平台消息
  void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) ;
  // 平台通道消息处理回调  
  PlatformMessageCallback get onPlatformMessage =&gt; _onPlatformMessage;

  ... //其它属性及回调

}
</code></pre>
<p>下面我们具体以一个例子来说明上面信息是如何使用的，在我们的应用开发过程中，我们需要响应各种手势事件来实现不同的功能，那么在Flutter中，手势事件是如何产生的呢？从Window中我们可以找到答案，我们看到有一个onPointerDataPacket函数回调，flutter就是通过该方法来接收系统底层传递过来的事件。</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onPointerDataPacket = (PointerDataPacket packet) {
    print(packet.data);
  };
}
</code></pre>
<p>上面是一个很简单的程序，就是当有手势事件产生的时候，直接打印事件数组。</p>
<p>运行该程序，当我们点击屏幕的时候，打印结果如下：</p>
<pre><code>I/flutter: [PointerData(x: 601.0, y: 565.0)]
I/flutter: [PointerData(x: 600.0, y: 565.0)]
I/flutter: [PointerData(x: 599.0, y: 566.0)]
I/flutter: [PointerData(x: 598.0, y: 568.0)]
I/flutter: [PointerData(x: 596.0, y: 572.0)]
</code></pre>
<p>上面的数据就是事件的原始数据，在Flutter中，Flutter Framework会对其进行封装处理和分发，最终才会被对应的组件消费，具体我们可以在GestureBinding类的initInstances方法中看到。</p>
<pre><code class="language-dart">mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onPointerDataPacket = _handlePointerDataPacket;
  }

    void _handlePointerDataPacket(ui.PointerDataPacket packet) {
    // We convert pointer data to logical pixels so that e.g. the touch slop can be
    // defined in a device-independent manner.
    _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, window.devicePixelRatio));
    if (!locked)
      _flushPointerEventQueue();
  }

    void _flushPointerEventQueue() {
    assert(!locked);
    while (_pendingPointerEvents.isNotEmpty)
      _handlePointerEvent(_pendingPointerEvents.removeFirst());
  }

  // ......
}
</code></pre>
<p>这里暂时进行深入，后续有机会会专门进行介绍。</p>
<p>不仅只有事件依赖于Window，从Window源码中我们可以很多东西都依赖于它，所以，学习Flutter源码的第一步就是弄清楚Window的作用。从这篇文章，我们可以看到Window是Flutter应用运行的纽带，它确保了Flutter Framework跟Engine之间的通信，如果没有Window这些接口的支撑，Framework只是一个没有灵魂的肉体。其实我们自己完全可以基于Window搭建一套自己的框架来取代Flutter Framework层。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenJDK源码下载]]></title>
        <id>https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai</id>
        <link href="https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai">
        </link>
        <updated>2019-09-29T01:25:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-源码下载">一、源码下载</h2>
<h3 id="1-安装mercurial版本控制">1、安装mercurial版本控制</h3>
<p>在MAC系统中，使用下面命令</p>
<pre><code>$ brew install mercurial
</code></pre>
<p>在Linux系统中，使用下面命令</p>
<pre><code>$ sudo apt-get install mercurial
</code></pre>
<p>mercurial安装完毕后，可以通过hg命令来下载源码，使用方式和git、svn类似。</p>
<h3 id="2-下载openjdk源码">2、下载OpenJDK源码</h3>
<pre><code>$ hg clone http://hg.openjdk.java.net/jdk8/jdk8 jdk8
</code></pre>
<p>你可以看到clone下来的代码很少，那是因为OpenJDK将不同类型的source文件放在了不同的子仓库，你可以进入OpenJDK的目录，执行get_source.sh文件即可。</p>
<pre><code>$ cd jdk8
$ chmod +x get_source.sh
$ ./get_source.sh
</code></pre>
<h3 id="3-配置jdk可选">3、配置JDK（可选）</h3>
<pre><code>$ bash configure
</code></pre>
<h3 id="4-构建编译">4、构建编译</h3>
<pre><code>$ make clean images
</code></pre>
<p>或者</p>
<pre><code>make clean images LOG=debug // to display DEBUG information
</code></pre>
<p>你也可以单独对某个模块进行编译构建</p>
<pre><code>$ make jdk
$ make hotspot
$ make test
</code></pre>
<h2 id="二-源码基本说明">二、源码基本说明</h2>
<p>— corba：不流行的多语言、分布式通讯接口<br>
— hotspot：Java 虚拟机<br>
— jaxp：XML 处理<br>
— jaxws：一组 XML web services 的 Java API<br>
— langtools：Java 语言工具<br>
— nashorn：JVM 上的 JavaScript 运行时<br>
— jdk：java 开发工具包<br>
jdk是我们研究源码经常会用到的，里面包含：<br>
— 针对操作系统的部分<br>
— share：与平台无关的实现</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://download.java.net/openjdk/jdk8<br>
https://www.jianshu.com/p/fd26b158dede<br>
https://adoptopenjdk.gitbooks.io/adoptopenjdk-getting-started-kit/en/binaries/build_openjdk_8.html<br>
https://hunterzhao.io/post/2018/01/29/compile-openjdk10-source-code-on-mac/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目团队管理]]></title>
        <id>https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li">
        </link>
        <updated>2019-09-19T15:58:25.000Z</updated>
        <content type="html"><![CDATA[<p>下面结合自身的项目经验，说说项目团队管理。</p>
<h4 id="1-新人分配导师">1、新人分配导师</h4>
<p>为新人工分配一个导师，由导师带领新人熟悉业务、工作流程以及公司环境。</p>
<h4 id="2-新人串讲">2、新人串讲</h4>
<p>新人进入团队之后，需要对自己所负责的模块进行串讲，并且由组内其他成为来进行提问打分，不通过的话就继续熟悉项目，然后继续串讲，直到通过为止。</p>
<h4 id="3-周报周会">3、周报（周会）</h4>
<p>项目组内所有成员每周都需要对自己工作内容进行总结并且写成周报，每周会有一次周会来进行工作内容汇总和讨论。</p>
<h4 id="4-技术分享">4、技术分享</h4>
<p>每周进行一次技术分享，由组内成员自发报名，分享内容包括技术调研，工作技术输出等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目分支管理]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li">
        </link>
        <updated>2019-09-18T13:55:17.000Z</updated>
        <content type="html"><![CDATA[<p>分支的管理对于项目的开发非常重要，下面结合自身项目经验说说分支的管理。</p>
<p>项目的代码分支主要有以下几条线：</p>
<p>(1) feature-v*：feature分支，用于各版本的feature迭代开发</p>
<p>(2) apk-dev：开发分支，用于编译线下测试版本（debug版本）</p>
<p>(3) apk-rel：发布分支，用于编译线上发布版本（release版本）</p>
<p>每一个版本建立一个专门的feature分支（比如，feature-v1, feature-v2, feature-v3......）。在一个版本开发完毕后，把feature分支merge到apk-dev分支；下一个版本以最新的apk-dev为base建立新的feature分支；apk-dev分支FC测试通过后将apk-dev分支merge到apk-rel分支上，然后apk-rel分支RC测试通过后即可进行上线发布。</p>
<p>feature-v* --&gt; apk-dev --&gt; apk-rel</p>
<p>另外附上一个参考链接：<br>
http://www.ruanyifeng.com/blog/2012/07/git.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目流程规范]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-liu-cheng-gui-fan</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-liu-cheng-gui-fan">
        </link>
        <updated>2019-09-18T13:50:41.000Z</updated>
        <content type="html"><![CDATA[<p>一个需求从立项到上线，会有一个漫长的协作过程，下面结合自身项目经验对整个过程进行总结。</p>
<h4 id="1-需求评审">1、需求评审</h4>
<p>参与角色：PM, RD, QA, UE</p>
<p>由PM主持，主要是对具体需求展开说明。</p>
<h4 id="2-交互评审">2、交互评审</h4>
<p>参与角色：UE, PM, RD, QA</p>
<p>由UE主持，主要是根据需求演示交互设计方案。</p>
<h4 id="3-case评审">3、case评审</h4>
<p>参与角色：QA, PM, RD, UE</p>
<p>由QA主持，主要是根据需求对具体case进行说明。</p>
<h4 id="4-开发">4、开发</h4>
<p>参与角色：RD</p>
<p>RD根据需求和设计进行需求开发</p>
<h4 id="5-测试">5、测试</h4>
<p>参与角色：QA</p>
<p>待RD需求提测之后，QA根据case进行测试，包括FC测试和RC测试。</p>
<h4 id="6-show-case">6、show case</h4>
<p>参与角色：QA, PM, RD, UE</p>
<p>待测试完成之后，PM组织所有人进行最终产品演示。</p>
<h4 id="7-灰度">7、灰度</h4>
<p>小范围发布上线，观察数据。</p>
<h4 id="8-发布">8、发布</h4>
<p>灰度稳定之后，全量发布。</p>
<figure data-type="image" tabindex="1"><img src="https://pianpian315.github.io/post-images/1568814716451.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目开发流程]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-kai-fa-liu-cheng</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-kai-fa-liu-cheng">
        </link>
        <updated>2019-09-18T13:39:07.000Z</updated>
        <content type="html"><![CDATA[<p>为了保证项目保质保量的推进，每一个项目需要有一个规范的开发流程，下面结合自身项目经验，对项目开发流程进行说明。</p>
<p>项目基本可以分为项目管理（需求）、文档管理（设计）、代码管理（开发）、持续交付（发布）四个过程。</p>
<h4 id="项目管理">项目管理</h4>
<p>主要是对需求、bug进行跟踪和管理。</p>
<h4 id="文档管理">文档管理</h4>
<p>主要是由RD对需求的开发说明文档进行输出。</p>
<h4 id="代码管理">代码管理</h4>
<p>主要是使用代码管理工具对代码进行管理，另外包括代码规范、代码质量检测。</p>
<h4 id="持续集成">持续集成</h4>
<p>流水线式的一站式编译发布和上线。主要包含自动化打包、测试（安全检测、性能检测、稳定性检测），发布。</p>
<figure data-type="image" tabindex="1"><img src="https://pianpian315.github.io/post-images/1568814432609.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java编码规范]]></title>
        <id>https://pianpian315.github.io/post/android-kai-fa-gong-cheng-neng-li</id>
        <link href="https://pianpian315.github.io/post/android-kai-fa-gong-cheng-neng-li">
        </link>
        <updated>2019-06-15T17:47:36.000Z</updated>
        <content type="html"><![CDATA[<p>Java的编码规范可以参考<a href="https://github.com/google/styleguide">Google编码规范</a>中的<a href="https://google.github.io/styleguide/javaguide.html">Java编码规范</a>和<a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf">阿里巴巴Java开发手册</a>中的Java开发规范。</p>
]]></content>
    </entry>
</feed>