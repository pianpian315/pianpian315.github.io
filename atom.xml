<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pianpian315.github.io</id>
    <title>Pianpian&apos;s Blog</title>
    <updated>2019-12-14T08:43:33.680Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pianpian315.github.io"/>
    <link rel="self" href="https://pianpian315.github.io/atom.xml"/>
    <subtitle>不积跬步，无以至千里</subtitle>
    <logo>https://pianpian315.github.io/images/avatar.png</logo>
    <icon>https://pianpian315.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Pianpian&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Git原理解析]]></title>
        <id>https://pianpian315.github.io/post/git-yuan-li-jie-xi</id>
        <link href="https://pianpian315.github.io/post/git-yuan-li-jie-xi">
        </link>
        <updated>2019-12-14T07:54:42.000Z</updated>
        <content type="html"><![CDATA[<p>Git是一个内容寻址文件系统。其核心部分是一个简单的键值对数据库，可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容，这些数据主要存放在.git/.git/objects目录下。</p>
<p>Git的这种数据存储方式类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。</p>
<p>除了上面说到的数据对象和树对象外，git还有另外两个基本对象类型，总共是四种基本对象类型。</p>
<ul>
<li>
<p>blobs<br>
这个就是数据对象，每个blob代表一个（版本的）文件，blob只包含文件的数据，而忽略文件的其他元数据，如名字、路径、格式等。</p>
</li>
<li>
<p>trees<br>
这个就是树对象，每个tree代表了一个目录的信息，包含了此目录下的blobs，子目录（对应于子trees），文件名、路径等元数据。因此，对于有子目录的目录，git相当于存储了嵌套的trees。</p>
</li>
<li>
<p>commits<br>
每个commit记录了提交一个更新的所有元数据，如指向的tree，父commit，作者、提交者、提交日期、提交日志等。每次提交都指向一个tree对象，记录了当次提交时的目录信息。一个commit可以有多个（至少一个）父commits。</p>
</li>
<li>
<p>tags<br>
tag用于给某个上述类型的对象指配一个便于开发者记忆的名字, 通常用于某次commit。</p>
</li>
</ul>
<p>下面我们来进行一下讲解和演示</p>
<pre><code>$ git init test
Initialized empty Git repository in /tmp/test/.git/
</code></pre>
<p>上面init命令就是在test目录下创建一个git仓库。</p>
<pre><code>$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
</code></pre>
<p>可以看到 Git 对 objects 目录进行了初始化，并创建了 pack 和 info 子目录，但均为空，因为当前还没有数据。</p>
<h3 id="数据对象blob">数据对象（blob）</h3>
<ul>
<li>向git数据库进行blob对象写入操作</li>
</ul>
<pre><code>$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
</code></pre>
<p>命令执行后，会返回个长度为40位的hash值，这个hash值是将待存储的数据外加一个头部信息一起做SHA-1校验运算而得的校验和。在git数据库中，它就是我们上面说的键值（key）。这个时候，'version 1'就写入到了git数据库中，它存放在.git/objects目录下，我们可以具体查看一下。</p>
<pre><code>$ find .git/objects/ -type f
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
</code></pre>
<p>可以看出，Git对象的40位hash分为两部分：头两位作为文件夹，后38位作为对象文件名。所以一个Git对象的存储路径规则为：</p>
<pre><code>.git/objects/hash[0, 2]/hash[2, 40]
</code></pre>
<ul>
<li>对blob对象进行查询操作</li>
</ul>
<p>我们也可以通过git cat-file这个git底层命令查看数据库中某一键值对应的数据。</p>
<pre><code>$ git cat-file -p 83baa
version 1
</code></pre>
<p>其中，-p选项用于查看键值对应的数据内容，83bba为数据键值的简写，只需要输入83baae61804e65cc73a7201a7252750c76066a30的部分就可以，不必把40个字符全部键入，可以看到输出了存入到数据库中的内容。</p>
<p>接下来，我们修改test.txt来看看效果</p>
<pre><code>$ echo &quot;version 2&quot; &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
</code></pre>
<p>我们发现，.git/objects下多出了一个文件，我们执行git cat-file搞清楚这两条数据的内容分别是什么。执行</p>
<pre><code>$ git cat-file -p 83baa
version 1
$git cat-file -p 1f7a7a
version 2
</code></pre>
<p>我们发现，test.txt的变更过程被完整的记录下来了。</p>
<p>另外，我们可以通过下面操作进行数据类型的查看</p>
<pre><code>$ git cat-file -t  83baa
 blob
$ git cat-file -t  1f7a7a
 blob
</code></pre>
<p>其中，-t选项用于查看键值对应数据的类型，可以看到输出了blob，也就是blob类型的对象，blob类型的对象解决的是文件内容存储的问题，它只关心文件内容，与文件的名字无关。而文件名的存储则需要通过树对象来解决。</p>
<p>下面用一个图表示这个blob对象。</p>
<figure data-type="image" tabindex="1"><img src="https://pianpian315.github.io/post-images/1576310393895.png" alt=""></figure>
<h3 id="树对象tree">树对象（tree）</h3>
<p>树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 一个树（tree）对象包含一条或多条记录，每条记录含有一个指向blob对象或tree对象的SHA-1指针，以及相应的模式、类型、文件名。</p>
<ul>
<li>向git数据库进行tree对象写入操作</li>
</ul>
<p>通常，Git根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象。</p>
<p>下面我们将test.txt的放入暂存区</p>
<pre><code>$ find .git/index
find: '.git/index': No such file or directory
$ git update-index --add test.txt
$ find .git/index
.git/index
</code></pre>
<p>我们注意.git/index文件的变化，在添加test.txt到暂存区前，index文件并不存在，这说明暂存区还没有创建。添加test.txt到暂存区的同时，index文件被创建。</p>
<pre><code>$ find .git/objects/ -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
$ git ls-files --stage
100644 83baae61804e65cc73a7201a7252750c76066a30 0    test.txt
</code></pre>
<p>可以看到，我们发现在执行git update-index 之后，git数据库并没有改变，依然是只有两条数据。通过git ls-files --stage查看暂存区内容，可以看到test.txt确实已经被暂存在缓冲区。</p>
<pre><code>$ git write-tree
2f39845a4a2c3ad86adebb00b1ddabd959c131c4
$ find .git/objects/ -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/2f/39845a4a2c3ad86adebb00b1ddabd959c131c4
</code></pre>
<p>在执行git write-tree之后，git数据库中多出了一条新的记录，键值为2f39845a4a2c3ad86adebb00b1ddabd959c131c4。</p>
<ul>
<li>对tree对象进行查询操作</li>
</ul>
<pre><code>$ git cat-file -t 2f3984
tree
$ git cat-file -p 2f3984
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	test.txt
</code></pre>
<p>由执行结果可见，git数据库中新增加的记录是一个tree对象，该tree对象指向一个blob对象。</p>
<p>更进一步，我们来看看是否能将一个子文件夹保存到tree对象</p>
<pre><code>$ mkdir new_dir
$ git update-index --add new_dir
error: new_dir: is a directory - add files inside instead
fatal: Unable to process path new_dir    
</code></pre>
<p>我们发现，无法将一个新建的空文件夹添加到暂存区。错误提示告诉我们，应该将文件将文件夹中的文件加入到暂存区（add files inside instead）。</p>
<p>接下来，我们在新建的文件夹下写入一个文件，再尝试将这一文件加入暂存区。</p>
<pre><code>$ echo &quot;new file&quot; &gt; new_dir/new
$ git update-index --add new_dir/new
$ git ls-files --stage 
100644 138c554a661371c9c40ae62dfb5d51b48b9b3f6b 0	new_dir/new
100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a 0	test.txt
$ git write-tree
514c3df17ea4fdf5de456905128e8a5a0a48b4b5
$ git cat-file -p 514c3
040000 tree 8d6bc0bdbba1d28caf4ee66a125169500080e206	new_dir
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	test.txt
$ git cat-file -p 8d6bc0
100644 blob 138c554a661371c9c40ae62dfb5d51b48b9b3f6b	new
</code></pre>
<p>从执行结果可见，文件夹new_dir对应一个tree对象，它这个tree对象里面包含了一个blob对象。</p>
<p>下面用一个图进行表示。</p>
<figure data-type="image" tabindex="2"><img src="https://pianpian315.github.io/post-images/1576311016532.png" alt=""></figure>
<h3 id="提交对象commit">提交对象（commit）</h3>
<p>commit对象能够帮你记录什么时间，由什么人，因为什么原因提交了一个新的版本，这个新的版本的父版本又是谁。</p>
<p>git提供了底层命令commit-tree来创建提交对象（commit object）</p>
<pre><code>$ git write-tree
514c3df17ea4fdf5de456905128e8a5a0a48b4b5

$ git commit-tree 514c3d -m &quot;first commit&quot;
9d8bc906e19c734a3aa6de9c7271f3c8bca84d9a

$ git cat-file -p 9d8bc90
tree 514c3df17ea4fdf5de456905128e8a5a0a48b4b5
author hupp &lt;hupp@xx.com&gt; 1575893692 +0800
committer hupp &lt;hupp@xx.com&gt; 1575893692 +0800
</code></pre>
<p>在git commit-tree命令中，-m选项用于指定本次提交的注释, -p指定该提交对象的父提交对象。</p>
<p>下面可以用一个图进行表示。</p>
<figure data-type="image" tabindex="3"><img src="https://pianpian315.github.io/post-images/1576310784143.png" alt=""></figure>
<h3 id="参考文章">参考文章</h3>
<p>https://zhuanlan.zhihu.com/p/45510461<br>
https://yanhaijing.com/git/2017/02/08/deep-git-3/<br>
https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1<br>
https://www.cnblogs.com/liyropt/archive/2012/12/11/2812194.html<br>
https://jingsam.github.io/2018/10/12/git-reference.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中Thread线程的中断]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-thread-xian-cheng-de-zhong-duan</id>
        <link href="https://pianpian315.github.io/post/java-zhong-thread-xian-cheng-de-zhong-duan">
        </link>
        <updated>2019-12-02T13:41:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="线程的中断">线程的中断</h3>
<p>在Java中，如果我们想要中断一个线程，需要调用Thread的interrupt方法。但是我们需要知道的是，中断一个线程并不是让一个线程停止运行，只是将线程的中断标志设为true, 或者在某些特定情况下抛出一个InterruptedException，并不会直接将一个线程停掉，也就是说，无论是设置中断标志还是抛出InterruptedException，它们都是给当前线程的建议，当前线程可以选择采纳或者不采纳，它们并不会影响当前线程的执行。</p>
<p>所以，中断操作大部分操作无外乎以下两点:<br>
（1）设置或者清除中断标志位<br>
（2）抛出InterruptedException</p>
<p>如果线程因为以下方法的调用而处于阻塞中，调用了interrupt方法之后，线程的中断标志会被清除，并且收到一个InterruptedException:</p>
<ul>
<li>Object的方法</li>
</ul>
<pre><code>wait()
wait(long)
wait(long, int)
</code></pre>
<ul>
<li>Thread的方法</li>
</ul>
<pre><code>join()
join(long)
join(long, int)
sleep(long)
sleep(long, int)
</code></pre>
<p>这里需要强调的是上面这些方法在抛出InterruptedException异常后，会同时清除中断标识位，所以我们如果想要知道线程是否中断，就只能通过异常来知晓，而不能通过标识位来获取。</p>
<h3 id="如何终止一个线程">如何终止一个线程</h3>
<p>（1）终止处于阻塞状态的线程</p>
<p>一个线程因为调用wait,sleep,join方法而进入阻塞状态后，若在这时中断这个线程，则这些方法将会抛出InterruptedException异常，我们可以利用这个异常，使线程跳出阻塞状态，从而终止线程。</p>
<pre><code>@Override
public void run() {
    while(true) {
        try {
            // do some task
            // blocked by calling wait/sleep/join
        } catch (InterruptedException ie) {  
            // 如果该线程被中断，则会抛出InterruptedException异常
            // 我们通过捕获这个异常，使得线程从block状态退出
            break; // 这里使用break, 可以使我们在线程中断后退出死循环，从而终止线程。
        }
    }
}
</code></pre>
<p>（2）终止处于运行状态的线程</p>
<p>与中断一个处于阻塞状态所不同的是，中断一个处于运行状态的线程只会将该线程的中断标志位设为true, 而并不会抛出InterruptedException异常，为了能在运行过程中感知到线程已经被中断了，我们只能通过不断地检查中断标志位来实现:</p>
<pre><code>@Override
public void run() {
    while (!isInterrupted()) {
        // do some task...
    }
}
</code></pre>
<p>综合上面两点，我们来看看怎样终止一个处于阻塞状态或运行状态的线程，也就是将这两种方法结合起来。</p>
<pre><code>@Override
public void run() {
    try {
        // 1. isInterrupted() 用于终止一个正在运行的线程。
        while (!isInterrupted()) {
            // 执行任务...
        }
    } catch (InterruptedException ie) {  
        // 2. InterruptedException异常用于终止一个处于阻塞状态的线程
    }
}
</code></pre>
<p>这里需要再次强调的是，wait,sleep,join等方法抛出InterruptedException有一个副作用: 清除当前的中断标志位，所以不要在异常抛出后不做任何处理，而寄望于用isInterrupted()方法来判断，因为中标志位已经被重置了。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://segmentfault.com/a/1190000016083002<br>
http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AQS 之 Condition 源码解析]]></title>
        <id>https://pianpian315.github.io/post/aqs-zhi-condition-yuan-ma-jie-xi</id>
        <link href="https://pianpian315.github.io/post/aqs-zhi-condition-yuan-ma-jie-xi">
        </link>
        <updated>2019-12-01T14:54:22.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道Java 中任何一个对象都拥有一组监视器方法，主要包括 wait()、wait(long timeout)、notify() 以及 notifyAll() 方法。而且这些方法使用时有个前提，就是必须先获得对象的监视器，也就是调用代码必须包含在 synchronized 语句中。而 Condition 是与 Lock 接口配合使用，使用 Condition 接口方法前必须先获得锁。</p>
<p>Condition 接口主要方法如下：</p>
<pre><code>public interface Condition {

    //在条件变量上等待，直至signal或者被interrupt
    void await() throws InterruptedException;

    //在条件变量上等待，直至signal，并且无视interrupt，这一点就比基于Object的wait更灵活
    void awaitUninterruptibly();

    //在条件变量上等待，直至signal或者被interrupt或者直至超时
    long awaitNanos(long nanosTimeout) throws InterruptedException;

    //在条件变量上等待，直至signal或者被interrupt或直至超时
    boolean await(long time, TimeUnit unit) throws InterruptedException;

    //在条件变量上等待，直至signal或者被interrupt或直至超时
    boolean awaitUntil(Date deadline) throws InterruptedException;

    //唤醒某个在条件变量上阻塞的线程，类似于notify
    void signal();

    //唤醒某个在条件变量上阻塞的线程，类似于notifyAll
    void signalAll();
}
</code></pre>
<p>Condition 对象是由 Lock 对象创建。</p>
<pre><code>Condition newCondition();
</code></pre>
<p>Condition只是个接口，主要实现类为 AbstractQueuedSynchronizer 中的内部类 ConditionObject。</p>
<pre><code>public class ConditionObject implements Condition, java.io.Serializable {
    /** First node of condition queue. */
    private transient Node firstWaiter;
    /** Last node of condition queue. */
    private transient Node lastWaiter;
}
</code></pre>
<p>每个 Condition 对象都包含着一个 FIFO 阻塞队列，ConditionObject 类中 firstWaiter、lastWaiter分别指向等待队列的首节点、尾节点。节点之间通过 nextWaiter 连接起来。</p>
<p>在AQS框架中，ConditionObject的实现需要这两个队列，一个就是上面看到的阻塞队列，阻塞队列(可以称为condition queue)是ConditionObject自身维护的，另一个队列就是同步队列，同步队列直接依赖于AQS的sync queue，因此ConditionObject作为内部类存在于AQS中，以便于ConditionObject可以直接利用AQS实现的sync queue。</p>
<p>下面说说两个队列是怎样工作的：<br>
（1）当调用await方法的时候，会将当前的线程添加到阻塞队列当中。</p>
<p>在ReentranLock中我们可以看到newCondition的方法实现。</p>
<pre><code>final ConditionObject newCondition() {
    return new ConditionObject();
}
</code></pre>
<p>下面我们具体来看看ConditionObject的await方法方法实现。</p>
<pre><code>public final void await() throws InterruptedException {
    // 响应中断，直接抛异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 在等待队列尾部添加节点
    Node node = addConditionWaiter();
    // 释放同步状态
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // 是否在同步队列中，signal会把当前节点从等待队列转移到同步队列
    while (!isOnSyncQueue(node)) {
        // 阻塞当前线程
        LockSupport.park(this);
        // 当前线程从 LockSupport.park(this) 返回
        // 1.signal 返回 2.被中断返回
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            // 如果是因为中断返回，则直接结束循环
            break;
    }
    // 重新获取同步状态
    // 如果在获取同步状态的时候被中断，则要重新中断
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    
    // 清除掉等待队列中已取消的节点
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    
    // 针对不同的中断模式做出相对应的操作
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
</code></pre>
<p>await()方法的大体逻辑：添加节点到等待队列的尾部，释放同步状态（锁），然后阻塞当前线程。当线程被唤醒后，重新获取同步状态（锁）。</p>
<p>下面看看添加节点到等待队列尾部的过程。</p>
<pre><code>private Node addConditionWaiter() {
    Node t = lastWaiter;
    // 如果尾节点已经被取消，则从等待队列中移除
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    // 以当前线程构建 Node
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        // 当前尾节点的下一个节点指向新构建的节点
        t.nextWaiter = node;
    // 指定当前节点为尾节点
    lastWaiter = node;
    return node;
}
</code></pre>
<p>（2）当调用signal方法的时候，会将当前线程中阻塞队列中移动到同步队列当中。</p>
<pre><code>/**
 * Moves the longest-waiting thread, if one exists, from the
 * wait queue for this condition to the wait queue for the
 * owning lock.
 *
 * 把等待队列中等待时间最长的节点（firstWaiter）移动到同步队列中去
 */
public final void signal() {
    // 调用该方法前必须先获得锁
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

/**
 * 转移等待队列中第一个节点到同步队列中
 * 如果移动失败（被取消），则移动下一个节点（下一个节点不为空）
 * 如果移动成功，退出循环
 */
private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);
}

/**
 * Transfers a node from a condition queue onto sync queue.
 * Returns true if successful.
 * @return true if successfully transferred (else the node was
 * cancelled before signal).
 *
 * 把节点从等待队列中转移到同步队列，转移成功返回 true
 * 失败则说明节点在 signal 前已经被取消
 */
final boolean transferForSignal(Node node) {
    // 更改状态失败，说明节点已经被取消
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    
    // 加到同步队列，p 是当前节点的前驱结点
    Node p = enq(node);
    int ws = p.waitStatus;
    // 前驱结点被取消，或者更改前驱结点状态为 signal 失败
    // 说明前驱节点已被取消，则直接唤醒当前线程
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}

</code></pre>
<p>signal() 方法的作用其实就是把等待队列中第一个非取消节点转移到 AQS 的同步队列尾部。</p>
<p>（3）在await方法中会通过isOnSyncQueue方法或者当前线程是否中断来决定是否退出阻塞，也就是结束while循环。</p>
<p>下面重点看看Condition#await() 方法中的部分代码。</p>
<pre><code>// 如果节点已在同步队列，跳出循环
while (!isOnSyncQueue(node)) {
    LockSupport.park(this);
    // 如果线程中断，也会跳出循环
    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
        break;
}
// 接着获取同步状态
if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
    interruptMode = REINTERRUPT;
</code></pre>
<p>从上面看到：<br>
1）通过isOnSyncQueue来判断当前线程释放在同步队列当中。</p>
<pre><code>final boolean isOnSyncQueue(Node node) {
    // 节点状态为 Node.CONDITION
    // 节点的 prev 节点为空（同步队列中节点的 prev 节点不会为空）
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    
    // 节点的 next 节点不为空（next 属性只会存在于同步队列，等待队列只有 nextWaiter）
    if (node.next != null) // If has successor, it must be on queue
        return true;
        
    // 上面条件都不满足，则从尾部遍历同步队列，查找指定节点
    return findNodeFromTail(node);
}
</code></pre>
<p>如果发现节点位于同步队列，说明另一个线程执行了signal/signalAll，节点从阻塞队列移动到同步队列，此时再次排队竞争锁，如果位于阻塞队列中，那么说明条件还未成立，需要继续阻塞自己。</p>
<p>2）通过checkInterruptWhileWaiting方法判断当前线程是否在阻塞的过程中被中断</p>
<pre><code>/**
 * Checks for interrupt, returning THROW_IE if interrupted
 * before signalled, REINTERRUPT if after signalled, or
 * 0 if not interrupted.
 *
 * 检查中断
 * 如果在被 signal 之前被中断，则返回 THROW_IE（直接抛异常）
 * 如果在被 signal 之后被中断，则返回 REINTERRUPT（再次中断）
 * 否则返回 0，表示没有被中断
 */
private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}

/**
 * Transfers node, if necessary, to sync queue after a cancelled
 * wait. Returns true if thread was cancelled before being
 * signalled.
 * 
 * 等待队列节点被取消（中断）后，尝试“转移”到同步队列
 */
final boolean transferAfterCancelledWait(Node node) {
    // 修改节点状态为初始状态
    // 修改成功，说明节点还没被 signal（signal 前中断）
    // 因为 signal 也会把节点状态修改为初始状态，如果已经被 signal，这里 cas 会失败
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        // 加入到同步队列尾部
        enq(node);
        return true;
    }
    /*
     * If we lost out to a signal(), then we can't proceed
     * until it finishes its enq().  Cancelling during an
     * incomplete transfer is both rare and transient, so just
     * spin.
     *
     * 代码执行到这里，说明当前线程正在或者已经被 signal（signal 后中断）
     * signal() 方法会把当前节点从等待队列“转移”到同步队列，即执行 enq() 方法，
     * 在完成“转移”之前，这里代码不能继续往下执行，所以做自旋操作就够了
     * 当节点成功“转移”到同步队列，isOnSyncQueue(node) 返回 true，则退出 while 循环
     *
     */
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
</code></pre>
<h3 id="参考文章">参考文章：</h3>
<p>https://somelogs.com/article/condition<br>
https://liuyehcf.github.io/2017/07/02/Java-concurrent-AQS-ConditionObject-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/<br>
https://zhuanlan.zhihu.com/p/39594030</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ScheduledThreadPoolExecutor源码解析]]></title>
        <id>https://pianpian315.github.io/post/scheduledthreadpoolexecutor-yuan-ma-jie-xi</id>
        <link href="https://pianpian315.github.io/post/scheduledthreadpoolexecutor-yuan-ma-jie-xi">
        </link>
        <updated>2019-11-29T16:48:31.000Z</updated>
        <content type="html"><![CDATA[<p>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor和实现了ScheduledExecutorService接口。是用于执行延时任务和周期任务的线程池。</p>
<p>主要有如下特点：</p>
<p>（1）将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响。</p>
<p>（2）ScheduledFutureTask实现了java.lang.Comparable接口和java.util.concurrent.Delayed接口，它们分别有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔，这样ScheduledFutureTask就是一个可以排序的任务。</p>
<pre><code>//还需要延迟多久
public long getDelay(TimeUnit unit) {
    return unit.convert(time - now(), NANOSECONDS);
}
//按预定的执行时间排序
public int compareTo(Delayed other) {
    if (other == this) // compare zero if same object
        return 0;
    if (other instanceof ScheduledFutureTask) {
        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;
        long diff = time - x.time;
        if (diff &lt; 0)
            return -1;
        else if (diff &gt; 0)
            return 1;
        else if (sequenceNumber &lt; x.sequenceNumber)
            return -1;
        else
            return 1;
    }
    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);
    return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;
}
</code></pre>
<p>（3）当有任务需要执行的时候，就会将任务加入到DelayedWorkQueue队列中，DelayedWorkQueue队列会根据compareTo的排序规则给队列元素排序，将执行时间早的任务放在队头，所以DelayedWorkQueue队列中的任务是一个按照执行时间从小到大排序的序列。</p>
<p>具体我们可以看看DelayedWorkQueue的几个关键方法。</p>
<h3 id="入队">入队</h3>
<p>入队的任务是ScheduledFutureTask对象，会通过ScheduledFutureTask的compareTo进行任务的比较。最早执行的任务（getDelay最小的）是根节点queue[0]。</p>
<pre><code>public boolean offer(Runnable x) {
 if (x == null)
     throw new NullPointerException();
 RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;
 final ReentrantLock lock = this.lock;
 lock.lock();
 try {
     int i = size;
     //1. 判断队列容量是否大于等于数组容量，是则需要扩容
     if (i &gt;= queue.length)
        //2. 扩容，每次扩容50%
         grow();
    //3. 队列容量+1
     size = i + 1;
     //4. 队列中还没有元素
     if (i == 0) {
         //5. 加入第一个元素
         queue[0] = e;
         setIndex(e, 0);
     } else {
         //6. 队列中已经有元素就需要进行排序。
         siftUp(i, e);
     }
     //7. 如果队头元素等于新的元素e，说明e执行时间比队列中其他元素早，唤醒消费线程，消费线程判断元素e是否达到执行时间。
     if (queue[0] == e) {
         leader = null;
         available.signal();
     }
 } finally {
     lock.unlock();
 }
 return true;
}

private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) {
    while (k &gt; 0) {
        //父节点
        int parent = (k - 1) &gt;&gt;&gt; 1;
        RunnableScheduledFuture&lt;?&gt; e = queue[parent];
        //如果比父节点大，确定位置
        if (key.compareTo(e) &gt;= 0)
            break;
        //如果比父节点小，和父节点交换位置，再和父节点的父节点比较。
        queue[k] = e;
        setIndex(e, k);
        k = parent;
    }
    queue[k] = key;
    setIndex(key, k);
}

</code></pre>
<h3 id="出队">出队</h3>
<p>queue[0]元素是根节点。判断根节点是否到了执行时间。如果到达了执行时间就直接将任务返回，如果没有到达执行时间就进入等待状态，等到了时间就会将任务返回。</p>
<pre><code>public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {
   final ReentrantLock lock = this.lock;
   lock.lockInterruptibly();
   try {
       for (;;) {
           //1. 获取队头节点
           RunnableScheduledFuture&lt;?&gt; first = queue[0];
           //2. 队头为空，没元素。进行等待。
           if (first == null)
               available.await();
           else {
               
               long delay = first.getDelay(NANOSECONDS);
               //3.判断队头节点是否到了执行时间
               if (delay &lt;= 0)
                   return finishPoll(first); //4. 返回队头节点，queue堆取掉头节点，进行调整

               //4.队头节点没到执行时间，进入等待
               first = null; 
               
               //这里是leader-follower模式的变种。为了减少不必要的等待。
               //不是leader的线程会进行永久的等待直到被唤醒。leader线程只会等待到下个个延迟。
               if (leader != null)
                   available.await();
               else {
                   Thread thisThread = Thread.currentThread();
                   leader = thisThread;
                   try {
                       available.awaitNanos(delay);
                   } finally {
                       if (leader == thisThread)
                           leader = null;
                   }
               }
           }
       }
   } finally {
       if (leader == null &amp;&amp; queue[0] != null)
           available.signal();
       lock.unlock();
   }
}

</code></pre>
<p>下面具体来看看ScheduledThreadPoolExecutor任务执行流程</p>
<h3 id="任务提交">任务提交</h3>
<p>以scheduleAtFiexedRate为例子。</p>
<pre><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                 long initialDelay,
                                                 long period,
                                                 TimeUnit unit) {
       if (command == null || unit == null)
           throw new NullPointerException();
       if (period &lt;= 0)
           throw new IllegalArgumentException();
       //1. 将任务封装成ScheduledFutureTask 
       ScheduledFutureTask&lt;Void&gt; sft =
           new ScheduledFutureTask&lt;Void&gt;(command,
                                         null,
                                         //triggerTime方法会算出触发的具体时间，now()+initalDelay
                                         triggerTime(initialDelay, unit),
                                         unit.toNanos(period));
       RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);
       //2.用outerTask保存当前任务。用于周期执行时，再次将任务加入队列。
       sft.outerTask = t;
       //3.延迟执行，将任务加入到DelayedWorkQueue队列中。
       delayedExecute(t);
       return t;
}
</code></pre>
<p>可以看到上面第三步的delayedExecute方法，就是将任务加入到DelayedWorkQueue队列中，然后启动工作线程进行任务执行的过程。</p>
<pre><code>private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {
    // 如果当前线程池处于SHUTDOWN状态，执行reject策略
    if (isShutdown())
        reject(task);
    else {
        // 否则，将task添加到task阻塞队列中
        super.getQueue().add(task);
        // 检查当前状态是否可以运行
        // 这里做了特殊检验：在SHUTDOWN状态,如果用户没有要求在SHUTDWON状态还可以接收新的task，那么下面会删除task
        if (isShutdown() &amp;&amp;
            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;
            remove(task))
            task.cancel(false);
        else
            // 调用ThreadPoolExecutor的ensurePrestart()执行task
            ensurePrestart();
    }
}
</code></pre>
<p>上面的getQueue().add(task)就是将任何加入到DelayedWorkQueue队列中，调用的是DelayedWorkQueue的add方法，下面具体看看实现。</p>
<pre><code>public boolean add(E e) {
    return offer(e);
}
</code></pre>
<p>可以看到最终调用的是offer函数，这个就是前面分析的DelayedWorkQueue的offer入队操作。</p>
<h3 id="任务执行">任务执行</h3>
<p>执行任务时调用ThreadPoolExecutor的runWorker方法。</p>
<pre><code>final void runWorker(Worker w) {
   Thread wt = Thread.currentThread();
   Runnable task = w.firstTask;
   w.firstTask = null;
   w.unlock(); 
   boolean completedAbruptly = true;
   try {
       //1.通过getTask方法从DelayedWorkQueue队列中拿出一个任务。
       //没有达到执行时间的任务时，会阻塞
       while (task != null || (task = getTask()) != null) {
           w.lock();
           if ((runStateAtLeast(ctl.get(), STOP) ||
                (Thread.interrupted() &amp;&amp;
                 runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
               !wt.isInterrupted())
               wt.interrupt();
           try {
               beforeExecute(wt, task);
               Throwable thrown = null;
               try {
               //2. 调用任务的run方法
                   task.run();
               } catch (RuntimeException x) {
                   thrown = x; throw x;
               } catch (Error x) {
                   thrown = x; throw x;
               } catch (Throwable x) {
                   thrown = x; throw new Error(x);
               } finally {
                   afterExecute(task, thrown);
               }
           } finally {
               task = null;
               w.completedTasks++;
               w.unlock();
           }
       }
       completedAbruptly = false;
   } finally {
       processWorkerExit(w, completedAbruptly);
   }
}
</code></pre>
<p>可以看到上面的操作主要分为两步：</p>
<p>（1）从DelayedWorkQueue队列中取任务，对应的就是getTask方法，getTask实现代码如下：</p>
<pre><code>private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
	    // 从DelayedWorkQueue队列中取出任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}

</code></pre>
<p>从上面的注释可以看到，最终调用的就是上面我们分析过的DelayedWorkQueue的take方法。</p>
<p>（2）进行任务的执行</p>
<pre><code>public void run() {
    //是否周期任务，period&gt;0
    boolean periodic = isPeriodic();
    if (!canRunInCurrentRunState(periodic))
        cancel(false);
    else if (!periodic)
        ScheduledFutureTask.super.run();
    //执行任务并重置任务状态
    else if (ScheduledFutureTask.super.runAndReset()) {
        //周期任务，设置下次执行的时间
        setNextRunTime();
        //再将outerTask（任务提交时将自身赋值给了outerTask）加入任务队列。
        reExecutePeriodic(outerTask);
    }
}

</code></pre>
<h3 id="参考文章">参考文章：</h3>
<p>https://www.jianshu.com/p/b52211d809df<br>
https://wujiazhen2.github.io/2018/09/25/ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/<br>
https://blog.csdn.net/u010014658/article/details/79219229</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中AQS实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-aqs-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-aqs-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:08:58.000Z</updated>
        <content type="html"><![CDATA[<p>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AQS内部有两个非常重要的参数：<br>
（1）state：state是int类型的，代表了加锁的状态。初始状态下，这个state的值是0。<br>
（2）exclusiveOwnerThread：用来记录当前加锁的的线程，初始化状态下，这个变量是null。</p>
<p>下面以ReentrantLock作为切入点来讲解AQS。</p>
<h3 id="锁的获取reentrantlocklock">锁的获取：ReentrantLock.lock()</h3>
<pre><code>public void lock() {
    sync.lock();
}
</code></pre>
<p>可以看到加锁操作实际是通过sync对象的lock()方法实现的，下面来看看这个sync对象。</p>
<pre><code>abstract static class Sync extends AbstractQueuedSynchronizer
</code></pre>
<p>sync是一个静态内部类，它继承了AQS这个抽象类，前面说过AQS是一个同步工具，主要用来实现同步控制。从这里也可以看到，ReentrantLock最终确实是使用这个工具实现同步控制功能。</p>
<p>通过源码可以看到，Sync这个类有两个具体的实现，分别是NofairSync(非公平锁),FailSync(公平锁)。</p>
<p>公平锁：表示所有线程严格按照FIFO来获取锁<br>
非公平锁：表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</p>
<p>首先具体来看看非公平锁NofairSyn作为主要分析逻辑。</p>
<pre><code>final void lock() {
    if (compareAndSetState(0, 1)) //通过cas操作来修改state状态，表示争抢锁的操作
      setExclusiveOwnerThread(Thread.currentThread());//设置当前获得锁状态的线程
    else
      acquire(1); //尝试去获取锁
}

</code></pre>
<p>上面过程分为三步：<br>
（1）上面说过state表示锁状态，通过CAS来修改锁的状态，如果修改成功，表示成功抢占到锁，否则表示抢占锁失败<br>
（2）上面说过，exclusiveOwnerThread表示当前加锁的线程，如果抢占到锁的话，接下来就是保存获得锁成功的当前线程<br>
（3）如果抢占锁失败，就会调用acquire来走锁竞争逻辑</p>
<p>到这里，我们可以看到AQS其实并没有我们想的那么复杂，就是通过state变量、加锁线程变量来记录加锁的状态，并且对其操作使用CAS进行原子操作。</p>
<p>而ReentrantLock这种东西只是一个外层的API，内核中的锁机制实现都是依赖AQS组件的。</p>
<p>下面来看看acquire的逻辑</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>上面的过程同样分为三步：<br>
（1）通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false。</p>
<p>tryAcquire不能直接调用，因为是否获取锁成功是由子类决定的，前面我们说到非公平锁是由NofairSync实现的，我们具体看看NofairSync的tryAcquire方法。</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    //获得当前执行的线程
    final Thread current = Thread.currentThread();
    int c = getState(); //获得state的值
    if (c == 0) { //state=0说明当前是无锁状态
        //通过cas操作来替换state的值改为1，因为在多线程环境中，直接修改state=1会存在线程安全问题
        if (compareAndSetState(0, acquires)) {
             //保存当前获得锁的线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires; //增加重入次数
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p>获取当前线程，判断当前的锁的状态<br>
如果state=0表示当前是无锁状态，通过cas更新state状态的值<br>
如果当前线程是属于重入，则增加重入次数</p>
<p>（2）如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</p>
<p>AQS内部有一条双向的队列存放等待线程，节点是Node对象。</p>
<pre><code>private Node addWaiter(Node mode) { //mode=Node.EXCLUSIVE
    //将当前线程封装成Node，并且mode为独占锁
    Node node = new Node(Thread.currentThread(), mode); 
    // Try the fast path of enq; backup to full enq on failure
    // tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法
    Node pred = tail;
    if (pred != null) { //tail不为空的情况，说明队列中存在节点数据
        node.prev = pred;  //讲当前线程的Node的prev节点指向tail
        if (compareAndSetTail(pred, node)) {//通过cas讲node添加到AQS队列
            pred.next = node;//cas成功，把旧的tail的next指针指向新的tail
            return node;
        }
    }
    enq(node); //tail=null，将node添加到同步队列中
    return node;
}
</code></pre>
<p>将当前线程封装成Node<br>
判断当前链表中的tail节点是否为空，如果不为空，则通过cas操作把当前线程的node添加到AQS队列<br>
如果为空或者cas失败，调用enq将节点添加到AQS队列</p>
<p>（3）调用acquireQueued进行锁的抢占和线程的挂起</p>
<p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作和线程挂起操作。</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();// 获取prev节点,若为null即刻抛出NullPointException
            if (p == head &amp;&amp; tryAcquire(arg)) {// 如果前驱为head才有资格进行锁的抢夺
                setHead(node); // 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点
//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null
                p.next = null; // help GC
                failed = false; //获取锁成功
                return interrupted;
            }
//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志
                interrupted = true;
        }
    } finally {
        if (failed) // 如果抛出异常则取消锁的获取,进行出队(sync queue)操作
            cancelAcquire(node);
    }
}
</code></pre>
<p>获取当前节点的prev节点<br>
如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁<br>
抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点<br>
如果获得锁失败，则根据waitStatus决定是否需要挂起线程<br>
最后，通过cancelAcquire取消获得锁的操作</p>
<h3 id="锁的释放reentrantlockunlock">锁的释放：ReentrantLock.unlock</h3>
<pre><code>public void unlock() {
    sync.release(1);
}
</code></pre>
<p>可以看到调用的其实就是前面说的NofairSyn的release方法。</p>
<pre><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
<p>这个方法里面做两件事，1，释放锁 ；2，唤醒park的线程</p>
<p>下面来看看NofairSyn的tryRelease方法。</p>
<pre><code>protected final boolean tryRelease(int releases) {
    int c = getState() - releases; // 这里是将锁的数量减1
    if (Thread.currentThread() != getExclusiveOwnerThread())// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { 
// 由于重入的关系，不是每次释放锁c都等于0，
    // 直到最后一次释放锁时，才会把当前线程释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<p>这就是将前面说的state变量、加锁线程变量进行重置的操作，因为他们记录的就是锁的状态，锁释放了这个状态也就重置为无锁状态了。也就是将state状态设置为0，将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。不过这里需要注意的是，只有state减1之后为0才会进行锁的释放，否则该线程还会继续持有锁，因为锁是可以重入的，如果state减1之后不为0就说明有重入线程。</p>
<p>当前线程被释放之后，就需要从阻塞队列中唤醒下一个节点的线程。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://segmentfault.com/a/1190000017372067<br>
https://mp.weixin.qq.com/s/atULuqIqhMcctG6xD3LgSA<br>
https://www.jianshu.com/p/fe027772e156<br>
https://blog.csdn.net/L_BestCoder/article/details/79306039</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中CAS的实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-cas-de-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-cas-de-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:05:28.000Z</updated>
        <content type="html"><![CDATA[<p>CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值。</p>
<p>在 java.util.concurrent 下面的源码中，Atomic, ReentrantLock 都使用了Unsafe类中的方法来保证并发的安全性，其内部实现就是利用CAS实现原子性操作的。</p>
<p>下面重点来看看AtomicInteger中getAndIncrement方法的实现</p>
<pre><code>//方法相当于原子性的 ++i
public final int getAndIncrement() {
    //三个参数，1、当前的实例 2、value实例变量的偏移量 3、递增的值。
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
</code></pre>
<p>CAS 操作包含三个操作数 ：内存偏移量位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<p>在 unsafe 中，getAndAddInt 如下：</p>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
	// //获取对象内存地址偏移量上的数值v
        v = getIntVolatile(o, offset);
	// //如果现在还是v,设置为 v + delta,否则返回false,继续循环再次重试.
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
</code></pre>
<p>在 getAndAddInt 方法中，会先使用 getIntVolatile 读取 Object 对应偏移 offset 中的值，从 Volatile 可以看出来这个值肯定是内存中实时的最新值。</p>
<p>得到最新值后，调用 compareAndSwapInt 来更新最新值，方法代码如下：</p>
<pre><code>public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
</code></pre>
<p>compareAndSwapInt 四个参数：</p>
<p>1、当前的实例<br>
2、实例变量的内存地址偏移量<br>
3、预期的旧值<br>
4、要更新的值</p>
<p>如果对象 o 中 offset 偏移位置的值等于期望值(expected)，就将该 offset 处的值更新为 x，当更新成功时，返回 true。结合前面调用来看，如果当前值是 v，就设置为 v+1，否则返回值为false。</p>
<p>下面来简单看看compareAndSwapInt的实现。</p>
<pre><code>// unsafe.cpp
/*
 * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，
 * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：
 *
 * 省略部分内容
 */
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
  oop p = JNIHandles::resolve(obj);
  // 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  // 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END

p是取出的对象，addr是p中offset处的地址，也就是取出p中偏移地址为offset的value值的地址addr，然后调用了Atomic::cmpxchg(x, addr, e)，其中参数x是即将更新的值，参数e是原内存的值。

// atomic.cpp
unsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) {
  assert(sizeof(unsigned int) == sizeof(jint), &quot;more work to do&quot;);
  /*
   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载
   * 函数。相关的预编译逻辑如下：
   *
   * atomic.inline.hpp：
   *    #include &quot;runtime/atomic.hpp&quot;
   *  
   *    // Linux
   *    #ifdef TARGET_OS_ARCH_linux_x86
   *    # include &quot;atomic_linux_x86.inline.hpp&quot;
   *    #endif
   * 
   *    // 省略部分代码
   *  
   *    // Windows
   *    #ifdef TARGET_OS_ARCH_windows_x86
   *    # include &quot;atomic_windows_x86.inline.hpp&quot;
   *    #endif
   *  
   *    // BSD
   *    #ifdef TARGET_OS_ARCH_bsd_x86
   *    # include &quot;atomic_bsd_x86.inline.hpp&quot;
   *    #endif
   *
   */
  return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest,
                                       (jint)compare_value);
}

</code></pre>
<p>上面其实就是根据不同的系统调用不同的实现，接下来，具体看看Linux X86平台下的 Atomic::cmpxchg 函数。</p>
<pre><code>inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;
                    : &quot;=a&quot; (exchange_value)
                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                    : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
}
</code></pre>
<p>os::is_MP判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p>
<p>其中，%1 就是exchange_value, %3是dest, %4就是mp， r表示任意寄存器，a还是eax寄存器。cmpxchgl会默认比较eax寄存器的值即compare_value和exchange_value的值，如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax。</p>
<p>可以看到，CAS 的实现离不开处理器的支持。核心代码就是一条带 lock 前缀的 cmpxchgl 指令，最终通过CPU的cmpxchgl指令的支持，实现AtomicInteger的CAS操作的原子性。。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://segmentfault.com/a/1190000015881923<br>
https://juejin.im/post/5a73cbbff265da4e807783f5<br>
https://blog.csdn.net/isea533/article/details/80301535<br>
https://www.cnblogs.com/dennyzhangdd/p/6734638.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中volatile实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-volatile-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-volatile-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:03:00.000Z</updated>
        <content type="html"><![CDATA[<p>volatile的作用就是在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<p>下面我们来看看volatile到底如何保证可见性的。</p>
<p>Java 代码：</p>
<pre><code>instance = new Singleton();//instance 是 volatile 变量
</code></pre>
<p>汇编代码：</p>
<pre><code>0x01a3de1d: movb $0x0,0x1104800(%esi);

0x01a3de24: lock addl $0x0,(%esp);
</code></pre>
<p>有 volatile 变量修饰的共享变量进行写操作的时候会多第二行汇编代码，lock 前缀的指令在多核处理器下会引发了两件事情。</p>
<p>（1）将当前处理器缓存行的数据会写回到系统内存。<br>
（2）这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效。</p>
<p>我们知道，处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完之后不知道何时会写到内存，这样就会出现数据不一致的问题，如果对声明了 Volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存，但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p>所以，最终可以总结为：<br>
（1）Lock 前缀指令会引起处理器缓存回写到内存。<br>
（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<p>这样最终就实现了数据的一致性，也就是可见性。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://www.infoq.cn/article/ftf-java-volatile/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java线程池ThreadPoolExecutor]]></title>
        <id>https://pianpian315.github.io/post/java-xian-cheng-chi-threadpoolexecutor</id>
        <link href="https://pianpian315.github.io/post/java-xian-cheng-chi-threadpoolexecutor">
        </link>
        <updated>2019-11-26T13:41:15.000Z</updated>
        <content type="html"><![CDATA[<p>线程池的作用就是实现对线程的统一管理和高效利用，具体使用线程池管理线程主要有如下好处：</p>
<p>（1）降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；<br>
（2）提升系统响应速度。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；<br>
（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</p>
<h3 id="1-threadpoolexecutor构造参数">1、ThreadPoolExecutor构造参数</h3>
<p>线程池的创建是由ThreadPoolExecutor类完成的，对于线程池的创建，我们必须弄清楚其构造参数：</p>
<pre><code>ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
</code></pre>
<p>corePoolSize：表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，不管当前核心线程池是否有空闲线程，都会创建新的线程来执行所提交的任务。如果调用了prestartCoreThread()或者 prestartAllCoreThreads()，那么线程池在创建的时候就会创建并且启动所有的核心线程。</p>
<p>maximumPoolSize：表示线程池能创建线程的最大个数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过maximumPoolSize的话，就会创建新的线程来执行任务。</p>
<p>keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了corePoolSize，并且线程空闲时间超过了keepAliveTime的话，就会将这些空闲线程销毁，这样可以尽可能降低系统资源消耗。默认情况下是不会回收core线程的，可以通过设置allowCoreThreadTimeOut改变这一行为。</p>
<p>unit：时间单位。为keepAliveTime指定时间单位。</p>
<p>workQueue：阻塞队列。用于保存任务的阻塞队列，当提交一个任务时，如果当前核心线程池的线程个数已经达到corePoolSize，并且阻塞队列还没有满的时候，就会将提交的任务加入到阻塞队列，当有空闲线程的时候，线程就会轮询该任务队列获取任务执行。阻塞队列可以使用ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。</p>
<p>threadFactory：创建线程都是通过ThreadFactory来实现的，如果没指定的话，默认会使用Executors.defaultThreadFactory()，一般来说，我们会在这里对线程设置名称、异常处理器等。</p>
<p>handler：线程池的饱和策略。当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<br>
（1）、AbortPolicy：直接抛出异常，默认策略；<br>
（2）、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>
（3）、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>
（4）、DiscardPolicy：直接丢弃任务；</p>
<h3 id="2-exectors工厂类">2、Exectors工厂类</h3>
<p><strong>newFixedThreadPool</strong></p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<p>可以看到，上面是创建一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列。</p>
<p><strong>newSingleThreadExecutor</strong></p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}
</code></pre>
<p>可以看到，上面创建了一个只有一个线程的线程池，corePoolSize和maximumPoolSize都是1，使用LinkedBlockingQueue作为阻塞队列，所以可以保证所提交任务顺序的执行。</p>
<p><strong>newCachedThreadPool</strong></p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<p>可以看到，上面创建的线程池中corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE，线程的缓存时间为60s，也就是当线程空闲并且超过60s时线程就会被回收，使用SynchronousQueue作为阻塞队列。</p>
<h3 id="3-如何合理的进行线程池参数的配置">3、如何合理的进行线程池参数的配置</h3>
<p>在我们平时的使用中，一般建议尽量少用上面所说的Exectors工厂方法来建立线程池，而是直接用ThreadPoolExecutor的构造函数，直接用构造方法的好处是我们可以充分的了解构造参数的作用，并且根据我们具体的业务需求来灵活的进行线程池的定制。</p>
<p>我们可以从以下角度来对任务进行划分：</p>
<p>（1）任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</p>
<p>对于任务性质不同的任务可以用不同规模的线程池分开处理：<br>
CPU密集型任务：配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。<br>
IO密集型任务：由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2xNcpu。<br>
混合型的任务：如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。</p>
<p>通常通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>（2）任务的优先级：高，中和低。<br>
优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>（3）任务的执行时间：长，中和短。<br>
执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>（4）任务的依赖性：是否依赖其他系统资源，如数据库连接。<br>
依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>另外，需要说明的是阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。</p>
<h3 id="4-源码解析">4、源码解析</h3>
<p><strong>线程池状态</strong></p>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// 线程池状态
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

// ctl操作
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>关于内部状态，主要是两个参数：<br>
runState：线程池运行状态<br>
workerCount：工作线程的数量</p>
<p>在上面代码中，我们可能发现找不到runState和workerCount两个变量，看到的是runStateOf和workerCountOf两个方法，没错，这两个方法的返回值就是上面的两个参数的值，线程池用一个32位的int来同时保存runState和workerCount，其中高3位是runState，其余29位是workerCount。代码中会反复使用runStateOf和workerCountOf来获取runState和workerCount。</p>
<p>线程池的状态主要有5种：<br>
RUNNING 111 表示正在运行<br>
SHUTDOWN 000 表示拒绝接收新的任务<br>
STOP 001 表示拒绝接收新的任务并且不再处理任务队列中剩余的任务，并且中断正在执行的任务。<br>
TIDYING 010 表示所有线程已停止，准备执行terminated()方法。<br>
TERMINATED 011 表示已执行完terminated()方法。</p>
<p><strong>任务提交</strong></p>
<p>线程池框架提供了两种方式提交任务，根据不同的业务需求选择不同的方式。<br>
Executor.execute():通过Executor.execute()方法提交的任务，必须实现Runnable接口，该方式提交的任务不能获取返回值，因此无法判断任务是否执行成功。<br>
ExecutorService.submit():通过ExecutorService.submit()方法提交的任务，可以获取任务执行完的返回值。</p>
<p><strong>任务执行</strong></p>
<p>下面我们来具体分析execute()方法，来看看任务的执行。</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    //情况1
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //情况2
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //情况3
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<p>以上代码对应了三种情况:</p>
<p>线程池的线程数量小于corePoolSize核心线程数量，开启核心线程执行任务。<br>
线程池的线程数量不小于corePoolSize核心线程数量，或者开启核心线程失败，尝试将任务以非阻塞的方式添加到任务队列。<br>
任务队列已满导致添加任务失败，开启新的非核心线程执行任务。</p>
<p>从上面的代码我们可以看到，线程池开启线程执行任务的操作就是将其封装成了Worker，具体对于的是addWorker方法。</p>
<pre><code> private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    //使用CAS机制轮询线程池的状态，如果线程池处于SHUTDOWN及大于它的状态则拒绝执行任务
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;

        //使用CAS机制尝试将当前线程数+1
        //如果是核心线程当前线程数必须小于corePoolSize 
        //如果是非核心线程则当前线程数必须小于maximumPoolSize
        //如果当前线程数小于线程池支持的最大线程数CAPACITY 也会返回失败
        for (;;) {
            int wc = workerCountOf(c);
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    //这里已经成功执行了CAS操作将线程池数量+1，下面创建线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        //Worker内部有一个Thread，并且执行Worker的run方法，因为Worker实现了Runnable
        final Thread t = w.thread;
        if (t != null) {
            //这里必须同步在状态为运行的情况下将Worker添加到workers中
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);  //把新建的woker线程放入集合保存，这里使用的是HashSet
                    int s = workers.size();
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            //如果添加成功则运行线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        //如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等等
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
</code></pre>
<p>addWorker这个方法先尝试在线程池运行状态为RUNNING并且线程数量未达上限的情况下通过CAS操作将线程池数量+1，接着在ReentrantLock同步锁的同步保证下判断线程池为运行状态，然后把Worker添加到HashSet workers中。如果添加成功则执行Worker的内部线程。</p>
<p>下面来看看Worker这个类，Worker是ThreadPoolExecutor的内部类，源码如下：</p>
<pre><code>private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker. */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
</code></pre>
<p>Worker就是对线程池中线程的封装，Worker构造方法指定了第一个要执行的任务firstTask，并通过线程池的线程工厂创建线程。可以发现这个线程的参数为this，即Worker对象，因为Worker实现了Runnable，因此可以被当成任务执行，所以当启动worker的线程的时候执行的即Worker实现的run方法：</p>
<pre><code>public void run() {
    runWorker(this);
}
</code></pre>
<p>从上代码可以看到，线程启动之后在线程中执行的就是这个worker内的任务，下面具体看看runWorker方法的实现。</p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 因为Worker的构造函数中setState(-1)禁止了中断，这里的unclock用于恢复中断
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        //一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //真正的任务执行逻辑
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                    afterExecute(task, thrown);
                }
            } finally {
                //这里设为null，也就是循环体再执行的时候会调用getTask方法
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作
        //比如在corePoolSize跟maximumPoolSize之间的woker会进行回收
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre>
<p>这个方法是线程池复用线程的核心代码，注意Worker继承了AbstractQueuedSynchronizer，在执行每个任务前通过lock方法加锁，执行完后通过unlock方法解锁，这种机制用来防止运行中的任务被中断。在执行任务时先尝试获取firstTask，即构造方法传入的Runnable对象，这个任务就是提交的这个本线程第一个需要执行的任务，如果该任务不为空，那么该线程首先就会执行该任务，否则如果这个任务为空，那么就尝试从getTask方法中获取任务队列中的任务进行执行。</p>
<p>下面重点说说getTask方法，getTask()实现跟我们构造参数keepAliveTime存活时间有关。我们都知道keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。</p>
<pre><code>private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            //根据超时配置有两种方法取出任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
</code></pre>
<p>这个getTask()方法通过一个循环不断轮询任务队列有没有任务到来，根据超时配置有两种方法取出任务方法：</p>
<p>BlockingQueue.poll这种方法会阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。因此实现了线程的退出与回收。<br>
BlockingQueue.take 这种方法会在取到任务前一直阻塞，直到取到任务就执行该任务，因此实现了线程可以一直执行由用户提交的任务。</p>
<p><strong>关闭线程池</strong></p>
<p>关闭线程池一般有两种形式，shutdown()和shutdownNow()</p>
<pre><code>public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        //通过CAS将状态更改为SHUTDOWN，这个时候线程池不接受新任务，但会继续处理队列中的任务
        advanceRunState(SHUTDOWN);
        //中断所有空闲的worker,也就是说除了正在处理任务的worker，其他阻塞在getTask()上的worker
        //都会被中断
        interruptIdleWorkers();
        //执行回调
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    //这个方法不会等待所有的任务处理完成才返回
}
public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        /*
            不同于shutdown()，会转换为STOP状态，不再处理新任务，队列中的任务也不处理，
            而且会中断所有的worker，而不只是空闲的worker
         */
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();//将所有的任务从队列中弹出
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}

private List&lt;Runnable&gt; drainQueue() {
    BlockingQueue&lt;Runnable&gt; q = workQueue;
    ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;();
    /*
        将队列中所有的任务remove掉，并添加到taskList中，
        但是有些队列比较特殊，比如说DelayQueue，如果第一个任务还没到过期时间，则不会弹出，
        因此这里通过调用toArray方法，然后再一个一个的remove掉
     */
    q.drainTo(taskList);
    if (!q.isEmpty()) {
        for (Runnable r : q.toArray(new Runnable[0])) {
            if (q.remove(r))
                taskList.add(r);
        }
    }
    return taskList;
}

</code></pre>
<p>可以看到，调用了shutdown()方法后，不会等待所有的任务处理完毕才返回，因此需要调用awaitTermination()来实现。</p>
<pre><code>public boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (;;) {
            //线程池若已经终结了，那么就返回
            if (runStateAtLeast(ctl.get(), TERMINATED))
                return true;
            //若超时了，也返回掉
            if (nanos &lt;= 0)
                return false;
            //阻塞在信号量上，等待线程池终结,但是要注意这个方法可能会因为一些未知原因随时唤醒当前线程，
            //因此需要重试，在tryTerminate()方法中，执行完terminated()回调后，表明线程池已经终结了,
            //然后会通过termination.signalAll()唤醒当前线程
            nanos = termination.awaitNanos(nanos);
        }
    } finally {
        mainLock.unlock();
    }
}

</code></pre>
<h3 id="参考文章">参考文章：</h3>
<p>https://juejin.im/post/5b8f97825188255c6140a50d<br>
https://www.jianshu.com/p/87bff5cc8d8c<br>
https://juejin.im/post/5aeec0106fb9a07ab379574f<br>
https://juejin.im/post/5b8f97825188255c6140a50d<br>
https://www.jianshu.com/p/f62a3f452869<br>
https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中synchronized实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li">
        </link>
        <updated>2019-11-20T14:15:47.000Z</updated>
        <content type="html"><![CDATA[<p>理解synchronized实现原理，需要弄清楚以下几点：</p>
<h3 id="1-java对象的组成">1、Java对象的组成</h3>
<p>在JVM中，每个Java对象由三部分组成：对象头、实例数据和对齐填充。</p>
<p>Java对象头：普通对象的对象头包括两部分：Mark Word 和 Class Metadata Address （类型指针），如果是数组对象还包括一个额外的Array length数组长度部分。<br>
实例变量：存放类的属性数据信息。<br>
填充数据：虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>这里，我们需要重点说说Java对象头。</p>
<h3 id="2-java对象头与锁的关系">2、Java对象头与锁的关系</h3>
<p>前面说过，Java对象头主要结构是由Mark Word 和 Class Metadata Address 组成。</p>
<p>对象头对应的内容在oopDesc里面，在hotspot源码 oop.hpp中对oopDesc进行了定义，定义如下：</p>
<pre><code>class oopDesc {
  friend class VMStructs;

 private:
  volatile markOop  _mark; // 对应Mark Word

  union _metadata {   // 对应Class Metadata Address
    Klass*      _klass;
    narrowKlass _compressed_klass;
  } _metadata;
}
</code></pre>
<p>Mark Word：存储对象自身的运行时数据，如对象的hashCode、锁信息或分代年龄或GC标志等信息。<br>
Class Metadata Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</p>
<p>这里需要重点说到的就是Mark Word，也就是上面的markOop，在Hotspot中，它的定义markOop.hpp文件中，代码如下：</p>
<pre><code>class markOopDesc: public oopDesc {

 private:
  // Conversion
  uintptr_t value() const { return (uintptr_t) this; }

 public:
  // Constants
  enum { age_bits                 = 4,  //分代年龄
         lock_bits                = 2, //锁标识
         biased_lock_bits         = 1, //是否为偏向锁
         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,
         hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits, //对象的hashcode
         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),
         epoch_bits               = 2 //偏向锁的时间戳
  };

...
</code></pre>
<p>从上面我们可以大致的看到Mark Word里面的存储内容，Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，下面以32位虚拟机为例。<br>
<img src="https://pianpian315.github.io/post-images/1574640692885.png" alt=""></p>
<p>可以看到Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，其实围绕这个锁的一系列操作都和Mark word有关系。</p>
<p>在JDK1.6之前，synchronized是一个重量级锁，从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，synchronized进行了优化，引入了 偏向锁和轻量级锁的概念。所以从JDK1.6开始，锁的状态根据竞争激烈程度从低到高分别是:无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。锁的状态会随着锁竞争的情况逐步升级，另外，为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。</p>
<h4 id="偏向锁">偏向锁</h4>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p>对于锁竞争比较激烈的场合，也就是每次申请锁的线程都是不相同的，这个时候偏向锁失败，此时Mark Word 的结构也变为轻量级锁的结构。引入轻量级锁的目的是在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗。</p>
<h4 id="重量级锁">重量级锁</h4>
<p>如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，重量级锁就是通过对象内部的监视器（monitor）实现。</p>
<p>markOopDesc里面扩展了自己的monitor方法，这个方法返回一个ObjectMonitor指针对象，在hotspot虚拟机中，就是使用这个ObjectMonitor类来实现monitor的。</p>
<pre><code>bool has_monitor() const {
  return ((value() &amp; monitor_value) != 0);
}

ObjectMonitor* monitor() const {
  assert(has_monitor(), &quot;check&quot;);

  // Use xor instead of &amp;~ to provide one extra tag-bit check.
  return (ObjectMonitor*) (value() ^ monitor_value);
}
</code></pre>
<p>在 ObjectMonitor.hpp中，可以看到ObjectMonitor的定义：</p>
<pre><code>class ObjectMonitor {
    ...

    ObjectMonitor() {
    _header       = NULL; //markOop对象头
    _count        = 0;    
    _waiters      = 0,   //等待线程数
    _recursions   = 0;   //重入次数
    _object       = NULL;  
    _owner        = NULL;  //获得ObjectMonitor对象的线程
    _WaitSet      = NULL;  //处于wait状态的线程，会被加入到waitSet
    _WaitSetLock  = 0 ; 
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁BLOCKED状态的线程
    _SpinFreq     = 0 ;   
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ; 
    _previous_owner_tid = 0; //监视器前一个拥有线程的ID
    }
    ...
}
</code></pre>
<p>在这里，我们可以知道每个对象都有一个monitor与之关联，monitor可以理解为一个对象监视器，这个对象监视器作为一个同步工具来记录和确保代码的同步性。</p>
<p>大致流程如下：</p>
<p>oopDesc–&gt;markOopDesc–方法monitor()–&gt;ObjectMonitor–&gt;enter、exit 获取、释放锁</p>
<p>当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。</p>
<p>若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：<br>
<img src="https://pianpian315.github.io/post-images/1574640708722.png" alt=""></p>
<h3 id="3-synchronized字节码">3、synchronized字节码</h3>
<p>下面从字节码入手，来看看synchronized作为实例锁的两种用法。</p>
<pre><code>public class App {
    public synchronized void test1() {
    }

    public void test2() {
        synchronized (this){
        }
    }

    public static void main( String[] args ){
        System.out.println( &quot;Hello World!&quot; );
    }
}
</code></pre>
<p>通过 javap -v App.class查看字节码。</p>
<pre><code>public synchronized void test1();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 同步修饰符
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  this   Lcom/gupaoedu/openclass/App;


  public void test2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter  //监视器进入，获取锁
         4: aload_1
         5: monitorexit  //监视器退出，释放锁
         6: goto          14
         9: astore_2
        10: aload_1
        11: monitorexit
        12: aload_2
        13: athrow
        14: return
</code></pre>
<p>同步块的实现使用monitorenter和monitorexit指令，而同步方法是依靠方法修饰符上的flag ACC_SYNCHRONIZED来完成。其本质就是通过锁对象头中的Mark word来实现的。</p>
<h3 id="参考文献">参考文献：</h3>
<p>https://blog.csdn.net/javazejian/article/details/72828483<br>
https://juejin.im/post/5b90cd7c5188255c877e20c8<br>
https://www.jianshu.com/p/c5058b6fe8e5<br>
https://www.cnblogs.com/dennyzhangdd/p/6734638.html<br>
https://tech.meituan.com/2018/11/15/java-lock.html<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483689&amp;idx=1&amp;sn=4bd727cc4991e54e273e099010c82d3b&amp;chksm=e96eaae7de1923f14db6ab744331c5f3ea1176af0cfd16df598f9e8817f2e4512dae6dd17d16&amp;token=860755966&amp;lang=zh_CN&amp;scene=21#wechat_redirect<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483699&amp;idx=1&amp;sn=9e51113bbbb3ae94d6b7273f3ee1b00f&amp;chksm=e96eaafdde1923eb6d3f721c902335c54037b503d5a3d7693e30246efa8356c41ea17bcfacc5&amp;token=1402731013&amp;lang=zh_CN#rd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的VSync机制]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi">
        </link>
        <updated>2019-11-10T06:42:05.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道，UI的显示是一帧一帧的，一次绘制过程，我们称其为一帧，在Flutter中，engine是通过VSync信号不断地触发每一帧的绘制，我们之所以说Flutter可以实现60fps，就是因为一秒钟可以触发60次重绘，那绘制是如何通过VSync信号进行驱动的呢？<br>
<img src="https://pianpian315.github.io/post-images/1573368494773.png" alt=""></p>
<p>VSync可以理解为一种定时中断，系统在每次可以进行绘制的时候都会发送VSync信号，CPU/GPU收到信号后马上处理绘制。所以，在Flutter中，当需要进行渲染绘制的时候，我们就需要监听VSync信号，当有VSync信号产生的时候，就可以绘制操作。<br>
<img src="https://pianpian315.github.io/post-images/1573368549589.png" alt=""></p>
<p>那现在的问题就是如果需要进行绘制操作，如何来监听这个VSync信号呢？我们首先需要通过引擎Engine的ScheduleFrame()方法来注册VSYNC信号回调，这个时候当Vsync信号到来的时候就会收到通知，然后就可以进行渲染绘制操作了。</p>
<p>ScheduleFrame()是Flutter Engine里面的方法，我们在Flutter Framework中如何调用到这个方法了，这个时候上一篇文章讲解的Window就发挥出作用了，在Window中有一个native的scheduleFrame方法，它调用的就是引擎Engine的ScheduleFrame()方法，跟Java中的JNI机制差不多，注册完成之后，当下一个VSync信息到来的时候，Window类中的_handleBeginFrame()和_handleDrawFrame()就会被回调，这样我们就可以收到绘制通知，具体的源码调用过程这里就不展开了，感兴趣的可以参考文章：http://gityuan.com/2019/06/15/flutter_ui_draw/。</p>
<p>下面我们同样举个例子来验证一下这个监听和回调过程：</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onBeginFrame = (Duration rawTimeStamp) {
    print(&quot;onBeginFrame: &quot; + rawTimeStamp.toString());
  };

  window.onDrawFrame = () {
    print(&quot;onDrawFrame&quot;);
  };

  print(&quot;scheduleFrame&quot;);
  window.scheduleFrame();
}
</code></pre>
<p>上面的代码很简单，首先实现了onBeginFrame和onDrawFrame回调，然后调用window的scheduleFrame注册VSync监听。</p>
<p>运行该程序，输出结果如下：</p>
<pre><code>I/flutter ( 4296): scheduleFrame
I/flutter ( 4296): onBeginFrame: 281:12:30.761601
I/flutter ( 4296): onDrawFrame
</code></pre>
<p>其实在Flutter Framework中，UI的渲染就是通过监听这个来触发的，Flutter Framework对其进行了封装，通过一个渲染流水线（Rendering pipline）来进行UI的渲染，具体我们在SchedulerBinding类中的initInstances方法中可以看到。</p>
<pre><code class="language-dart">mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onBeginFrame = _handleBeginFrame;
    window.onDrawFrame = _handleDrawFrame;
    
    // ......
  }

  void _handleBeginFrame(Duration rawTimeStamp) {
    if (_warmUpFrame) {
      assert(!_ignoreNextEngineDrawFrame);
      _ignoreNextEngineDrawFrame = true;
      return;
    }
    handleBeginFrame(rawTimeStamp);
  }

  void _handleDrawFrame() {
    if (_ignoreNextEngineDrawFrame) {
      _ignoreNextEngineDrawFrame = false;
      return;
    }
    handleDrawFrame();
  }
  
  // ......
}
</code></pre>
<p>上面的代码涉及到渲染的整个流水线过程，这里就不进行展开，后面会专门进行分析，这里需要重点理解的是整个Vsync机制，它是UI绘制的发动机，通过它的驱动UI才能不断的进行绘制。</p>
<h3 id="参考文章">参考文章</h3>
<p>https://juejin.im/post/5b7767fef265da43803bdc65<br>
http://gityuan.com/2019/06/15/flutter_ui_draw/<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html<br>
https://www.jianshu.com/p/a9364f778bf8<br>
https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://coolegos.github.io/2017/10/18/Andorid%E4%B8%ADVSync%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/</p>
]]></content>
    </entry>
</feed>