<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pianpian315.github.io</id>
    <title>Pianpian&apos;s Blog</title>
    <updated>2019-11-10T06:58:52.459Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pianpian315.github.io"/>
    <link rel="self" href="https://pianpian315.github.io/atom.xml"/>
    <subtitle>不积跬步，无以至千里</subtitle>
    <logo>https://pianpian315.github.io/images/avatar.png</logo>
    <icon>https://pianpian315.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Pianpian&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Flutter中的VSync机制]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi">
        </link>
        <updated>2019-11-10T06:42:05.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道，UI的显示是一帧一帧的，一次绘制过程，我们称其为一帧，在Flutter中，engine是通过VSync信号不断地触发每一帧的绘制，我们之所以说Flutter可以实现60fps，就是因为一秒钟可以触发60次重绘，那绘制是如何通过VSync信号进行驱动的呢？<br>
<img src="https://pianpian315.github.io/post-images/1573368494773.png" alt=""></p>
<p>VSync可以理解为一种定时中断，系统在每次可以进行绘制的时候都会发送VSync信号，CPU/GPU收到信号后马上处理绘制。所以，在Flutter中，当需要进行渲染绘制的时候，我们就需要监听VSync信号，当有VSync信号产生的时候，就可以绘制操作。<br>
<img src="https://pianpian315.github.io/post-images/1573368549589.png" alt=""></p>
<p>那现在的问题就是如果需要进行绘制操作，如何来监听这个VSync信号呢？我们首先需要通过引擎Engine的ScheduleFrame()方法来注册VSYNC信号回调，这个时候当Vsync信号到来的时候就会收到通知，然后就可以进行渲染绘制操作了。</p>
<p>ScheduleFrame()是Flutter Engine里面的方法，我们在Flutter Framework中如何调用到这个方法了，这个时候上一篇文章讲解的Window就发挥出作用了，在Window中有一个native的scheduleFrame方法，它调用的就是引擎Engine的ScheduleFrame()方法，跟Java中的JNI机制差不多，注册完成之后，当下一个VSync信息到来的时候，Window类中的_handleBeginFrame()和_handleDrawFrame()就会被回调，这样我们就可以收到绘制通知，具体的源码调用过程这里就不展开了，感兴趣的可以参考文章：http://gityuan.com/2019/06/15/flutter_ui_draw/。</p>
<p>下面我们同样举个例子来验证一下这个监听和回调过程：</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onBeginFrame = (Duration rawTimeStamp) {
    print(&quot;onBeginFrame: &quot; + rawTimeStamp.toString());
  };

  window.onDrawFrame = () {
    print(&quot;onDrawFrame&quot;);
  };

  print(&quot;scheduleFrame&quot;);
  window.scheduleFrame();
}
</code></pre>
<p>上面的代码很简单，首先实现了onBeginFrame和onDrawFrame回调，然后调用window的scheduleFrame注册VSync监听。</p>
<p>运行该程序，输出结果如下：</p>
<pre><code>I/flutter ( 4296): scheduleFrame
I/flutter ( 4296): onBeginFrame: 281:12:30.761601
I/flutter ( 4296): onDrawFrame
</code></pre>
<p>其实在Flutter Framework中，UI的渲染就是通过监听这个来触发的，Flutter Framework对其进行了封装，通过一个渲染流水线（Rendering pipline）来进行UI的渲染，具体我们在SchedulerBinding类中的initInstances方法中可以看到。</p>
<pre><code class="language-dart">mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onBeginFrame = _handleBeginFrame;
    window.onDrawFrame = _handleDrawFrame;
    
    // ......
  }

  void _handleBeginFrame(Duration rawTimeStamp) {
    if (_warmUpFrame) {
      assert(!_ignoreNextEngineDrawFrame);
      _ignoreNextEngineDrawFrame = true;
      return;
    }
    handleBeginFrame(rawTimeStamp);
  }

  void _handleDrawFrame() {
    if (_ignoreNextEngineDrawFrame) {
      _ignoreNextEngineDrawFrame = false;
      return;
    }
    handleDrawFrame();
  }
  
  // ......
}
</code></pre>
<p>上面的代码涉及到渲染的整个流水线过程，这里就不进行展开，后面会专门进行分析，这里需要重点理解的是整个Vsync机制，它是UI绘制的发动机，通过它的驱动UI才能不断的进行绘制。</p>
<h3 id="参考文章">参考文章</h3>
<p>https://juejin.im/post/5b7767fef265da43803bdc65<br>
http://gityuan.com/2019/06/15/flutter_ui_draw/<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html<br>
https://www.jianshu.com/p/a9364f778bf8<br>
https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://coolegos.github.io/2017/10/18/Andorid%E4%B8%ADVSync%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的Window]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-window</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-window">
        </link>
        <updated>2019-11-10T06:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>在Flutter中，Window类是Flutter Framework跟宿主系统相连接的接口，宿主系统通过Window类开放了各种各样的回调方法以及native调用接口供Flutter Framework使用。Window类来自库dart:ui，相关源代码在window.dart中，我们来具体看看其代码。</p>
<pre><code class="language-dart">/// The [Window] singleton. This object exposes the size of the display, the
/// core scheduler API, the input event callback, the graphics drawing API, and
/// other such core services.
final Window window = new Window._();
</code></pre>
<p>上面代码是Window实例化的过程，从注释我们可以知道，Window是一个单例对象，它对上层提供屏幕尺寸，调度接口，输入事件回调，图形绘制接口以及其他一些核心服务。正是因为如此，我们才可以通过window来获取底层系统传递过来的各种各样的信息，另外，window也提供了一些native调用，方便上层进行一些系统调用。</p>
<p>下面来具体看看核心代码：</p>
<pre><code class="language-dart">class Window {

  // 当前设备的DPI，即一个逻辑像素显示多少物理像素，数字越大，显示效果就越精细保真。
  // DPI是设备屏幕的固件属性，如Nexus 6的屏幕DPI为3.5 
  double get devicePixelRatio =&gt; _devicePixelRatio;

  // Flutter UI绘制区域的大小
  Size get physicalSize =&gt; _physicalSize;

  // 当前系统默认的语言Locale
  Locale get locale;

  // 当前系统字体缩放比例。  
  double get textScaleFactor =&gt; _textScaleFactor;  

  // 当绘制区域大小改变回调
  VoidCallback get onMetricsChanged =&gt; _onMetricsChanged;  
  // Locale发生变化回调
  VoidCallback get onLocaleChanged =&gt; _onLocaleChanged;
  // 系统字体缩放变化回调
  VoidCallback get onTextScaleFactorChanged =&gt; _onTextScaleFactorChanged;
  // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用
  FrameCallback get onBeginFrame =&gt; _onBeginFrame;
  // 绘制回调  
  VoidCallback get onDrawFrame =&gt; _onDrawFrame;
  // 点击或指针事件回调
  PointerDataPacketCallback get onPointerDataPacket =&gt; _onPointerDataPacket;
  // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用，
  // 此方法会直接调用Flutter engine的Window_scheduleFrame方法
  void scheduleFrame() native 'Window_scheduleFrame';
  // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法
  void render(Scene scene) native 'Window_render';

  // 发送平台消息
  void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) ;
  // 平台通道消息处理回调  
  PlatformMessageCallback get onPlatformMessage =&gt; _onPlatformMessage;

  ... //其它属性及回调

}
</code></pre>
<p>下面我们具体以一个例子来说明上面信息是如何使用的，在我们的应用开发过程中，我们需要响应各种手势事件来实现不同的功能，那么在Flutter中，手势事件是如何产生的呢？从Window中我们可以找到答案，我们看到有一个onPointerDataPacket函数回调，flutter就是通过该方法来接收系统底层传递过来的事件。</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onPointerDataPacket = (PointerDataPacket packet) {
    print(packet.data);
  };
}
</code></pre>
<p>上面是一个很简单的程序，就是当有手势事件产生的时候，直接打印事件数组。</p>
<p>运行该程序，当我们点击屏幕的时候，打印结果如下：</p>
<pre><code>I/flutter: [PointerData(x: 601.0, y: 565.0)]
I/flutter: [PointerData(x: 600.0, y: 565.0)]
I/flutter: [PointerData(x: 599.0, y: 566.0)]
I/flutter: [PointerData(x: 598.0, y: 568.0)]
I/flutter: [PointerData(x: 596.0, y: 572.0)]
</code></pre>
<p>上面的数据就是事件的原始数据，在Flutter中，Flutter Framework会对其进行封装处理和分发，最终才会被对应的组件消费，具体我们可以在GestureBinding类的initInstances方法中看到。</p>
<pre><code class="language-dart">mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onPointerDataPacket = _handlePointerDataPacket;
  }

    void _handlePointerDataPacket(ui.PointerDataPacket packet) {
    // We convert pointer data to logical pixels so that e.g. the touch slop can be
    // defined in a device-independent manner.
    _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, window.devicePixelRatio));
    if (!locked)
      _flushPointerEventQueue();
  }

    void _flushPointerEventQueue() {
    assert(!locked);
    while (_pendingPointerEvents.isNotEmpty)
      _handlePointerEvent(_pendingPointerEvents.removeFirst());
  }

  // ......
}
</code></pre>
<p>这里暂时进行深入，后续有机会会专门进行介绍。</p>
<p>不仅只有事件依赖于Window，从Window源码中我们可以很多东西都依赖于它，所以，学习Flutter源码的第一步就是弄清楚Window的作用。从这篇文章，我们可以看到Window是Flutter应用运行的纽带，它确保了Flutter Framework跟Engine之间的通信，如果没有Window这些接口的支撑，Framework只是一个没有灵魂的肉体。其实我们自己完全可以基于Window搭建一套自己的框架来取代Flutter Framework层。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenJDK源码下载]]></title>
        <id>https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai</id>
        <link href="https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai">
        </link>
        <updated>2019-09-29T01:25:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-源码下载">一、源码下载</h2>
<h3 id="1-安装mercurial版本控制">1、安装mercurial版本控制</h3>
<pre><code>$ brew install mercurial
</code></pre>
<p>mercurial安装完毕后，可以通过hg命令来下载源码，使用方式和git、svn类似。</p>
<h3 id="2-下载openjdk源码">2、下载OpenJDK源码</h3>
<pre><code>$ hg clone http://hg.openjdk.java.net/jdk8/jdk8 jdk8
</code></pre>
<p>你可以看到clone下来的代码很少，那是因为OpenJDK将不同类型的source文件放在了不同的子仓库，你可以进入OpenJDK的目录，执行get_source.sh文件即可。</p>
<pre><code>$ cd jdk8
$ chmod +x get_source.sh
$ ./get_source.sh
</code></pre>
<h3 id="3-配置jdk可选">3、配置JDK（可选）</h3>
<pre><code>$ bash configure
</code></pre>
<h3 id="4-构建编译">4、构建编译</h3>
<pre><code>$ make clean images
</code></pre>
<p>或者</p>
<pre><code>make clean images LOG=debug // to display DEBUG information
</code></pre>
<p>你也可以单独对某个模块进行编译构建</p>
<pre><code>$ make jdk
$ make hotspot
$ make test
</code></pre>
<h2 id="二-源码基本说明">二、源码基本说明</h2>
<p>— corba：不流行的多语言、分布式通讯接口<br>
— hotspot：Java 虚拟机<br>
— jaxp：XML 处理<br>
— jaxws：一组 XML web services 的 Java API<br>
— langtools：Java 语言工具<br>
— nashorn：JVM 上的 JavaScript 运行时<br>
— jdk：java 开发工具包<br>
jdk是我们研究源码经常会用到的，里面包含：<br>
— 针对操作系统的部分<br>
— share：与平台无关的实现</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://download.java.net/openjdk/jdk8<br>
https://www.jianshu.com/p/fd26b158dede<br>
https://adoptopenjdk.gitbooks.io/adoptopenjdk-getting-started-kit/en/binaries/build_openjdk_8.html<br>
https://hunterzhao.io/post/2018/01/29/compile-openjdk10-source-code-on-mac/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈项目团队管理]]></title>
        <id>https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li">
        </link>
        <updated>2019-09-19T15:58:25.000Z</updated>
        <content type="html"><![CDATA[<p>下面结合自身的项目经验，说说项目团队管理。</p>
<h4 id="1-新人分配导师">1、新人分配导师</h4>
<p>为新人工分配一个导师，由导师带领新人熟悉业务、工作流程以及公司环境。</p>
<h4 id="2-新人串讲">2、新人串讲</h4>
<p>新人进入团队之后，需要对自己所负责的模块进行串讲，并且由组内其他成为来进行提问打分，不通过的话就继续熟悉项目，然后继续串讲，直到通过为止。</p>
<h4 id="3-周报周会">3、周报（周会）</h4>
<p>项目组内所有成员每周都需要对自己工作内容进行总结并且写成周报，每周会有一次周会来进行工作内容汇总和讨论。</p>
<h4 id="4-技术分享">4、技术分享</h4>
<p>每周进行一次技术分享，由组内成员自发报名，分享内容包括技术调研，工作技术输出等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈项目分支管理]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li">
        </link>
        <updated>2019-09-18T13:55:17.000Z</updated>
        <content type="html"><![CDATA[<p>分支的管理对于项目的开发非常重要，下面结合自身项目经验说说分支的管理。</p>
<p>项目的代码分支主要有以下几条线：</p>
<p>(1) feature-v*：feature分支，用于各版本的feature迭代开发</p>
<p>(2) apk-dev：开发分支，用于编译线下测试版本（debug版本）</p>
<p>(3) apk-rel：发布分支，用于编译线上发布版本（release版本）</p>
<p>每一个版本建立一个专门的feature分支（比如，feature-v1, feature-v2, feature-v3......）。在一个版本开发完毕后，把feature分支merge到apk-dev分支；下一个版本以最新的apk-dev为base建立新的feature分支；apk-dev分支FC测试通过后将apk-dev分支merge到apk-rel分支上，然后apk-rel分支RC测试通过后即可进行上线发布。</p>
<p>feature-v* --&gt; apk-dev --&gt; apk-rel</p>
<p>另外附上一个参考链接：<br>
http://www.ruanyifeng.com/blog/2012/07/git.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈项目流程规范]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-liu-cheng-gui-fan</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-liu-cheng-gui-fan">
        </link>
        <updated>2019-09-18T13:50:41.000Z</updated>
        <content type="html"><![CDATA[<p>一个需求从立项到上线，会有一个漫长的协作过程，下面结合自身项目经验对整个过程进行总结。</p>
<h4 id="1-需求评审">1、需求评审</h4>
<p>参与角色：PM, RD, QA, UE</p>
<p>由PM主持，主要是对具体需求展开说明。</p>
<h4 id="2-交互评审">2、交互评审</h4>
<p>参与角色：UE, PM, RD, QA</p>
<p>由UE主持，主要是根据需求演示交互设计方案。</p>
<h4 id="3-case评审">3、case评审</h4>
<p>参与角色：QA, PM, RD, UE</p>
<p>由QA主持，主要是根据需求对具体case进行说明。</p>
<h4 id="4-开发">4、开发</h4>
<p>参与角色：RD</p>
<p>RD根据需求和设计进行需求开发</p>
<h4 id="5-测试">5、测试</h4>
<p>参与角色：QA</p>
<p>待RD需求提测之后，QA根据case进行测试，包括FC测试和RC测试。</p>
<h4 id="6-show-case">6、show case</h4>
<p>参与角色：QA, PM, RD, UE</p>
<p>待测试完成之后，PM组织所有人进行最终产品演示。</p>
<h4 id="7-灰度">7、灰度</h4>
<p>小范围发布上线，观察数据。</p>
<h4 id="8-发布">8、发布</h4>
<p>灰度稳定之后，全量发布。</p>
<figure data-type="image" tabindex="1"><img src="https://pianpian315.github.io/post-images/1568814716451.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈项目开发流程]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-kai-fa-liu-cheng</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-kai-fa-liu-cheng">
        </link>
        <updated>2019-09-18T13:39:07.000Z</updated>
        <content type="html"><![CDATA[<p>为了保证项目保质保量的推进，每一个项目需要有一个规范的开发流程，下面结合自身项目经验，对项目开发流程进行说明。</p>
<p>项目基本可以分为项目管理（需求）、文档管理（设计）、代码管理（开发）、持续交付（发布）四个过程。</p>
<h4 id="项目管理">项目管理</h4>
<p>主要是对需求、bug进行跟踪和管理。</p>
<h4 id="文档管理">文档管理</h4>
<p>主要是由RD对需求的开发说明文档进行输出。</p>
<h4 id="代码管理">代码管理</h4>
<p>主要是使用代码管理工具对代码进行管理，另外包括代码规范、代码质量检测。</p>
<h4 id="持续集成">持续集成</h4>
<p>流水线式的一站式编译发布和上线。主要包含自动化打包、测试（安全检测、性能检测、稳定性检测），发布。</p>
<figure data-type="image" tabindex="1"><img src="https://pianpian315.github.io/post-images/1568814432609.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java编码规范]]></title>
        <id>https://pianpian315.github.io/post/android-kai-fa-gong-cheng-neng-li</id>
        <link href="https://pianpian315.github.io/post/android-kai-fa-gong-cheng-neng-li">
        </link>
        <updated>2019-06-15T17:47:36.000Z</updated>
        <content type="html"><![CDATA[<p>Java的编码规范可以参考<a href="https://github.com/google/styleguide">Google编码规范</a>中的<a href="https://google.github.io/styleguide/javaguide.html">Java编码规范</a>和<a href="https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf">阿里巴巴Java开发手册</a>中的Java开发规范。</p>
]]></content>
    </entry>
</feed>