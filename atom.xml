<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pianpian315.github.io</id>
    <title>Pianpian&apos;s Blog</title>
    <updated>2019-11-27T14:17:10.672Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pianpian315.github.io"/>
    <link rel="self" href="https://pianpian315.github.io/atom.xml"/>
    <subtitle>不积跬步，无以至千里</subtitle>
    <logo>https://pianpian315.github.io/images/avatar.png</logo>
    <icon>https://pianpian315.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Pianpian&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Java中AQS实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-aqs-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-aqs-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:08:58.000Z</updated>
        <content type="html"><![CDATA[<p>AQS即是AbstractQueuedSynchronizer，一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。</p>
<p>AQS内部有两个非常重要的参数：<br>
（1）state：state是int类型的，代表了加锁的状态。初始状态下，这个state的值是0。<br>
（2）exclusiveOwnerThread：用来记录当前加锁的的线程，初始化状态下，这个变量是null。</p>
<p>下面以ReentrantLock作为切入点来讲解AQS。</p>
<h3 id="锁的获取reentrantlocklock">锁的获取：ReentrantLock.lock()</h3>
<pre><code>public void lock() {
    sync.lock();
}
</code></pre>
<p>可以看到加锁操作实际是通过sync对象的lock()方法实现的，下面来看看这个sync对象。</p>
<pre><code>abstract static class Sync extends AbstractQueuedSynchronizer
</code></pre>
<p>sync是一个静态内部类，它继承了AQS这个抽象类，前面说过AQS是一个同步工具，主要用来实现同步控制。从这里也可以看到，ReentrantLock最终确实是使用这个工具实现同步控制功能。</p>
<p>通过源码可以看到，Sync这个类有两个具体的实现，分别是NofairSync(非公平锁),FailSync(公平锁)。</p>
<p>公平锁：表示所有线程严格按照FIFO来获取锁<br>
非公平锁：表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</p>
<p>首先具体来看看非公平锁NofairSyn作为主要分析逻辑。</p>
<pre><code>final void lock() {
    if (compareAndSetState(0, 1)) //通过cas操作来修改state状态，表示争抢锁的操作
      setExclusiveOwnerThread(Thread.currentThread());//设置当前获得锁状态的线程
    else
      acquire(1); //尝试去获取锁
}

</code></pre>
<p>上面过程分为三步：<br>
（1）上面说过state表示锁状态，通过CAS来修改锁的状态，如果修改成功，表示成功抢占到锁，否则表示抢占锁失败<br>
（2）上面说过，exclusiveOwnerThread表示当前加锁的线程，如果抢占到锁的话，接下来就是保存获得锁成功的当前线程<br>
（3）如果抢占锁失败，就会调用acquire来走锁竞争逻辑</p>
<p>到这里，我们可以看到AQS其实并没有我们想的那么复杂，就是通过state变量、加锁线程变量来记录加锁的状态，并且对其操作使用CAS进行原子操作。</p>
<p>而ReentrantLock这种东西只是一个外层的API，内核中的锁机制实现都是依赖AQS组件的。</p>
<p>下面来看看acquire的逻辑</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>上面的过程同样分为三步：<br>
（1）通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false。</p>
<p>tryAcquire不能直接调用，因为是否获取锁成功是由子类决定的，前面我们说到非公平锁是由NofairSync实现的，我们具体看看NofairSync的tryAcquire方法。</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    //获得当前执行的线程
    final Thread current = Thread.currentThread();
    int c = getState(); //获得state的值
    if (c == 0) { //state=0说明当前是无锁状态
        //通过cas操作来替换state的值改为1，因为在多线程环境中，直接修改state=1会存在线程安全问题
        if (compareAndSetState(0, acquires)) {
             //保存当前获得锁的线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires; //增加重入次数
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p>获取当前线程，判断当前的锁的状态<br>
如果state=0表示当前是无锁状态，通过cas更新state状态的值<br>
如果当前线程是属于重入，则增加重入次数</p>
<p>（2）如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</p>
<p>AQS内部有一条双向的队列存放等待线程，节点是Node对象。</p>
<pre><code>private Node addWaiter(Node mode) { //mode=Node.EXCLUSIVE
    //将当前线程封装成Node，并且mode为独占锁
    Node node = new Node(Thread.currentThread(), mode); 
    // Try the fast path of enq; backup to full enq on failure
    // tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法
    Node pred = tail;
    if (pred != null) { //tail不为空的情况，说明队列中存在节点数据
        node.prev = pred;  //讲当前线程的Node的prev节点指向tail
        if (compareAndSetTail(pred, node)) {//通过cas讲node添加到AQS队列
            pred.next = node;//cas成功，把旧的tail的next指针指向新的tail
            return node;
        }
    }
    enq(node); //tail=null，将node添加到同步队列中
    return node;
}
</code></pre>
<p>将当前线程封装成Node<br>
判断当前链表中的tail节点是否为空，如果不为空，则通过cas操作把当前线程的node添加到AQS队列<br>
如果为空或者cas失败，调用enq将节点添加到AQS队列</p>
<p>（3）调用acquireQueued进行锁的抢占和线程的挂起</p>
<p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作和线程挂起操作。</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();// 获取prev节点,若为null即刻抛出NullPointException
            if (p == head &amp;&amp; tryAcquire(arg)) {// 如果前驱为head才有资格进行锁的抢夺
                setHead(node); // 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点
//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null
                p.next = null; // help GC
                failed = false; //获取锁成功
                return interrupted;
            }
//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志
                interrupted = true;
        }
    } finally {
        if (failed) // 如果抛出异常则取消锁的获取,进行出队(sync queue)操作
            cancelAcquire(node);
    }
}
</code></pre>
<p>获取当前节点的prev节点<br>
如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁<br>
抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点<br>
如果获得锁失败，则根据waitStatus决定是否需要挂起线程<br>
最后，通过cancelAcquire取消获得锁的操作</p>
<h3 id="锁的释放reentrantlockunlock">锁的释放：ReentrantLock.unlock</h3>
<pre><code>public void unlock() {
    sync.release(1);
}
</code></pre>
<p>可以看到调用的其实就是前面说的NofairSyn的release方法。</p>
<pre><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
<p>这个方法里面做两件事，1，释放锁 ；2，唤醒park的线程</p>
<p>下面来看看NofairSyn的tryRelease方法。</p>
<pre><code>protected final boolean tryRelease(int releases) {
    int c = getState() - releases; // 这里是将锁的数量减1
    if (Thread.currentThread() != getExclusiveOwnerThread())// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { 
// 由于重入的关系，不是每次释放锁c都等于0，
    // 直到最后一次释放锁时，才会把当前线程释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<p>这就是将前面说的state变量、加锁线程变量进行重置的操作，因为他们记录的就是锁的状态，锁释放了这个状态也就重置为无锁状态了。也就是将state状态设置为0，将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。不过这里需要注意的是，只有state减1之后为0才会进行锁的释放，否则该线程还会继续持有锁，因为锁是可以重入的，如果state减1之后不为0就说明有重入线程。</p>
<p>当前线程被释放之后，就需要从阻塞队列中唤醒下一个节点的线程。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://segmentfault.com/a/1190000017372067<br>
https://mp.weixin.qq.com/s/atULuqIqhMcctG6xD3LgSA<br>
https://www.jianshu.com/p/fe027772e156<br>
https://blog.csdn.net/L_BestCoder/article/details/79306039</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中CAS的实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-cas-de-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-cas-de-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:05:28.000Z</updated>
        <content type="html"><![CDATA[<p>CAS的全称为Compare And Swap，直译就是比较交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值。</p>
<p>在 java.util.concurrent 下面的源码中，Atomic, ReentrantLock 都使用了Unsafe类中的方法来保证并发的安全性，其内部实现就是利用CAS实现原子性操作的。</p>
<p>下面重点来看看AtomicInteger中getAndIncrement方法的实现</p>
<pre><code>//方法相当于原子性的 ++i
public final int getAndIncrement() {
    //三个参数，1、当前的实例 2、value实例变量的偏移量 3、递增的值。
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
</code></pre>
<p>CAS 操作包含三个操作数 ：内存偏移量位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。</p>
<p>在 unsafe 中，getAndAddInt 如下：</p>
<pre><code>public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
	// //获取对象内存地址偏移量上的数值v
        v = getIntVolatile(o, offset);
	// //如果现在还是v,设置为 v + delta,否则返回false,继续循环再次重试.
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}
</code></pre>
<p>在 getAndAddInt 方法中，会先使用 getIntVolatile 读取 Object 对应偏移 offset 中的值，从 Volatile 可以看出来这个值肯定是内存中实时的最新值。</p>
<p>得到最新值后，调用 compareAndSwapInt 来更新最新值，方法代码如下：</p>
<pre><code>public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);
</code></pre>
<p>compareAndSwapInt 四个参数：</p>
<p>1、当前的实例<br>
2、实例变量的内存地址偏移量<br>
3、预期的旧值<br>
4、要更新的值</p>
<p>如果对象 o 中 offset 偏移位置的值等于期望值(expected)，就将该 offset 处的值更新为 x，当更新成功时，返回 true。结合前面调用来看，如果当前值是 v，就设置为 v+1，否则返回值为false。</p>
<p>下面来简单看看compareAndSwapInt的实现。</p>
<pre><code>// unsafe.cpp
/*
 * 这个看起来好像不像一个函数，不过不用担心，不是重点。UNSAFE_ENTRY 和 UNSAFE_END 都是宏，
 * 在预编译期间会被替换成真正的代码。下面的 jboolean、jlong 和 jint 等是一些类型定义（typedef）：
 *
 * 省略部分内容
 */
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
  oop p = JNIHandles::resolve(obj);
  // 根据偏移量，计算 value 的地址。这里的 offset 就是 AtomaicInteger 中的 valueOffset
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  // 调用 Atomic 中的函数 cmpxchg，该函数声明于 Atomic.hpp 中
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END

p是取出的对象，addr是p中offset处的地址，也就是取出p中偏移地址为offset的value值的地址addr，然后调用了Atomic::cmpxchg(x, addr, e)，其中参数x是即将更新的值，参数e是原内存的值。

// atomic.cpp
unsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) {
  assert(sizeof(unsigned int) == sizeof(jint), &quot;more work to do&quot;);
  /*
   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载
   * 函数。相关的预编译逻辑如下：
   *
   * atomic.inline.hpp：
   *    #include &quot;runtime/atomic.hpp&quot;
   *  
   *    // Linux
   *    #ifdef TARGET_OS_ARCH_linux_x86
   *    # include &quot;atomic_linux_x86.inline.hpp&quot;
   *    #endif
   * 
   *    // 省略部分代码
   *  
   *    // Windows
   *    #ifdef TARGET_OS_ARCH_windows_x86
   *    # include &quot;atomic_windows_x86.inline.hpp&quot;
   *    #endif
   *  
   *    // BSD
   *    #ifdef TARGET_OS_ARCH_bsd_x86
   *    # include &quot;atomic_bsd_x86.inline.hpp&quot;
   *    #endif
   *
   */
  return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest,
                                       (jint)compare_value);
}

</code></pre>
<p>上面其实就是根据不同的系统调用不同的实现，接下来，具体看看Linux X86平台下的 Atomic::cmpxchg 函数。</p>
<pre><code>inline jint Atomic::cmpxchg(jint exchange_value, volatile jint* dest, jint compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;
                    : &quot;=a&quot; (exchange_value)
                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                    : &quot;cc&quot;, &quot;memory&quot;);
  return exchange_value;
}
</code></pre>
<p>os::is_MP判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p>
<p>其中，%1 就是exchange_value, %3是dest, %4就是mp， r表示任意寄存器，a还是eax寄存器。cmpxchgl会默认比较eax寄存器的值即compare_value和exchange_value的值，如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax。</p>
<p>可以看到，CAS 的实现离不开处理器的支持。核心代码就是一条带 lock 前缀的 cmpxchgl 指令，最终通过CPU的cmpxchgl指令的支持，实现AtomicInteger的CAS操作的原子性。。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://segmentfault.com/a/1190000015881923<br>
https://juejin.im/post/5a73cbbff265da4e807783f5<br>
https://blog.csdn.net/isea533/article/details/80301535<br>
https://www.cnblogs.com/dennyzhangdd/p/6734638.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中volatile实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-volatile-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-volatile-shi-xian-yuan-li">
        </link>
        <updated>2019-11-27T14:03:00.000Z</updated>
        <content type="html"><![CDATA[<p>volatile的作用就是在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<p>下面我们来看看volatile到底如何保证可见性的。</p>
<p>Java 代码：</p>
<pre><code>instance = new Singleton();//instance 是 volatile 变量
</code></pre>
<p>汇编代码：</p>
<pre><code>0x01a3de1d: movb $0x0,0x1104800(%esi);

0x01a3de24: lock addl $0x0,(%esp);
</code></pre>
<p>有 volatile 变量修饰的共享变量进行写操作的时候会多第二行汇编代码，lock 前缀的指令在多核处理器下会引发了两件事情。</p>
<p>（1）将当前处理器缓存行的数据会写回到系统内存。<br>
（2）这个写回内存的操作会引起在其他 CPU 里缓存了该内存地址的数据无效。</p>
<p>我们知道，处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存后再进行操作，但操作完之后不知道何时会写到内存，这样就会出现数据不一致的问题，如果对声明了 Volatile 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存，但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p>所以，最终可以总结为：<br>
（1）Lock 前缀指令会引起处理器缓存回写到内存。<br>
（2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<p>这样最终就实现了数据的一致性，也就是可见性。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://www.infoq.cn/article/ftf-java-volatile/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java线程池ThreadPoolExecutor]]></title>
        <id>https://pianpian315.github.io/post/java-xian-cheng-chi-threadpoolexecutor</id>
        <link href="https://pianpian315.github.io/post/java-xian-cheng-chi-threadpoolexecutor">
        </link>
        <updated>2019-11-26T13:41:15.000Z</updated>
        <content type="html"><![CDATA[<p>线程池的作用就是实现对线程的统一管理和高效利用，具体使用线程池管理线程主要有如下好处：</p>
<p>（1）降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗；<br>
（2）提升系统响应速度。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度；<br>
（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。</p>
<h3 id="1-threadpoolexecutor构造参数">1、ThreadPoolExecutor构造参数</h3>
<p>线程池的创建是由ThreadPoolExecutor类完成的，对于线程池的创建，我们必须弄清楚其构造参数：</p>
<pre><code>ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
</code></pre>
<p>corePoolSize：表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，不管当前核心线程池是否有空闲线程，都会创建新的线程来执行所提交的任务。如果调用了prestartCoreThread()或者 prestartAllCoreThreads()，那么线程池在创建的时候就会创建并且启动所有的核心线程。</p>
<p>maximumPoolSize：表示线程池能创建线程的最大个数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过maximumPoolSize的话，就会创建新的线程来执行任务。</p>
<p>keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了corePoolSize，并且线程空闲时间超过了keepAliveTime的话，就会将这些空闲线程销毁，这样可以尽可能降低系统资源消耗。默认情况下是不会回收core线程的，可以通过设置allowCoreThreadTimeOut改变这一行为。</p>
<p>unit：时间单位。为keepAliveTime指定时间单位。</p>
<p>workQueue：阻塞队列。用于保存任务的阻塞队列，当提交一个任务时，如果当前核心线程池的线程个数已经达到corePoolSize，并且阻塞队列还没有满的时候，就会将提交的任务加入到阻塞队列，当有空闲线程的时候，线程就会轮询该任务队列获取任务执行。阻塞队列可以使用ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。</p>
<p>threadFactory：创建线程都是通过ThreadFactory来实现的，如果没指定的话，默认会使用Executors.defaultThreadFactory()，一般来说，我们会在这里对线程设置名称、异常处理器等。</p>
<p>handler：线程池的饱和策略。当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<br>
（1）、AbortPolicy：直接抛出异常，默认策略；<br>
（2）、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>
（3）、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>
（4）、DiscardPolicy：直接丢弃任务；</p>
<h3 id="2-exectors工厂类">2、Exectors工厂类</h3>
<p><strong>newFixedThreadPool</strong></p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<p>可以看到，上面是创建一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列。</p>
<p><strong>newSingleThreadExecutor</strong></p>
<pre><code>public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}
</code></pre>
<p>可以看到，上面创建了一个只有一个线程的线程池，corePoolSize和maximumPoolSize都是1，使用LinkedBlockingQueue作为阻塞队列，所以可以保证所提交任务顺序的执行。</p>
<p><strong>newCachedThreadPool</strong></p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<p>可以看到，上面创建的线程池中corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE，线程的缓存时间为60s，也就是当线程空闲并且超过60s时线程就会被回收，使用SynchronousQueue作为阻塞队列。</p>
<h3 id="3-如何合理的进行线程池参数的配置">3、如何合理的进行线程池参数的配置</h3>
<p>在我们平时的使用中，一般建议尽量少用上面所说的Exectors工厂方法来建立线程池，而是直接用ThreadPoolExecutor的构造函数，直接用构造方法的好处是我们可以充分的了解构造参数的作用，并且根据我们具体的业务需求来灵活的进行线程池的定制。</p>
<p>我们可以从以下角度来对任务进行划分：</p>
<p>（1）任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</p>
<p>对于任务性质不同的任务可以用不同规模的线程池分开处理：<br>
CPU密集型任务：配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。<br>
IO密集型任务：由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2xNcpu。<br>
混合型的任务：如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。</p>
<p>通常通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>（2）任务的优先级：高，中和低。<br>
优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>（3）任务的执行时间：长，中和短。<br>
执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>（4）任务的依赖性：是否依赖其他系统资源，如数据库连接。<br>
依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>另外，需要说明的是阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。</p>
<h3 id="4-源码解析">4、源码解析</h3>
<p><strong>线程池状态</strong></p>
<pre><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// 线程池状态
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

// ctl操作
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre>
<p>关于内部状态，主要是两个参数：<br>
runState：线程池运行状态<br>
workerCount：工作线程的数量</p>
<p>在上面代码中，我们可能发现找不到runState和workerCount两个变量，看到的是runStateOf和workerCountOf两个方法，没错，这两个方法的返回值就是上面的两个参数的值，线程池用一个32位的int来同时保存runState和workerCount，其中高3位是runState，其余29位是workerCount。代码中会反复使用runStateOf和workerCountOf来获取runState和workerCount。</p>
<p>线程池的状态主要有5种：<br>
RUNNING 111 表示正在运行<br>
SHUTDOWN 000 表示拒绝接收新的任务<br>
STOP 001 表示拒绝接收新的任务并且不再处理任务队列中剩余的任务，并且中断正在执行的任务。<br>
TIDYING 010 表示所有线程已停止，准备执行terminated()方法。<br>
TERMINATED 011 表示已执行完terminated()方法。</p>
<p><strong>任务提交</strong></p>
<p>线程池框架提供了两种方式提交任务，根据不同的业务需求选择不同的方式。<br>
Executor.execute():通过Executor.execute()方法提交的任务，必须实现Runnable接口，该方式提交的任务不能获取返回值，因此无法判断任务是否执行成功。<br>
ExecutorService.submit():通过ExecutorService.submit()方法提交的任务，可以获取任务执行完的返回值。</p>
<p><strong>任务执行</strong></p>
<p>下面我们来具体分析execute()方法，来看看任务的执行。</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    //情况1
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    //情况2
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    //情况3
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre>
<p>以上代码对应了三种情况:</p>
<p>线程池的线程数量小于corePoolSize核心线程数量，开启核心线程执行任务。<br>
线程池的线程数量不小于corePoolSize核心线程数量，或者开启核心线程失败，尝试将任务以非阻塞的方式添加到任务队列。<br>
任务队列已满导致添加任务失败，开启新的非核心线程执行任务。</p>
<p>从上面的代码我们可以看到，线程池开启线程执行任务的操作就是将其封装成了Worker，具体对于的是addWorker方法。</p>
<pre><code> private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    //使用CAS机制轮询线程池的状态，如果线程池处于SHUTDOWN及大于它的状态则拒绝执行任务
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;

        //使用CAS机制尝试将当前线程数+1
        //如果是核心线程当前线程数必须小于corePoolSize 
        //如果是非核心线程则当前线程数必须小于maximumPoolSize
        //如果当前线程数小于线程池支持的最大线程数CAPACITY 也会返回失败
        for (;;) {
            int wc = workerCountOf(c);
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    //这里已经成功执行了CAS操作将线程池数量+1，下面创建线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        //Worker内部有一个Thread，并且执行Worker的run方法，因为Worker实现了Runnable
        final Thread t = w.thread;
        if (t != null) {
            //这里必须同步在状态为运行的情况下将Worker添加到workers中
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);  //把新建的woker线程放入集合保存，这里使用的是HashSet
                    int s = workers.size();
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            //如果添加成功则运行线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        //如果woker启动失败，则进行一些善后工作，比如说修改当前woker数量等等
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
</code></pre>
<p>addWorker这个方法先尝试在线程池运行状态为RUNNING并且线程数量未达上限的情况下通过CAS操作将线程池数量+1，接着在ReentrantLock同步锁的同步保证下判断线程池为运行状态，然后把Worker添加到HashSet workers中。如果添加成功则执行Worker的内部线程。</p>
<p>下面来看看Worker这个类，Worker是ThreadPoolExecutor的内部类，源码如下：</p>
<pre><code>private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker. */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
</code></pre>
<p>Worker就是对线程池中线程的封装，Worker构造方法指定了第一个要执行的任务firstTask，并通过线程池的线程工厂创建线程。可以发现这个线程的参数为this，即Worker对象，因为Worker实现了Runnable，因此可以被当成任务执行，所以当启动worker的线程的时候执行的即Worker实现的run方法：</p>
<pre><code>public void run() {
    runWorker(this);
}
</code></pre>
<p>从上代码可以看到，线程启动之后在线程中执行的就是这个worker内的任务，下面具体看看runWorker方法的实现。</p>
<pre><code>final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 因为Worker的构造函数中setState(-1)禁止了中断，这里的unclock用于恢复中断
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        //一般情况下，task都不会为空（特殊情况上面注释中也说明了），因此会直接进入循环体中
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //真正的任务执行逻辑
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    //该方法是个空的实现，如果有需要用户可以自己继承该类进行实现
                    afterExecute(task, thrown);
                }
            } finally {
                //这里设为null，也就是循环体再执行的时候会调用getTask方法
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //当指定任务执行完成，阻塞队列中也取不到可执行任务时，会进入这里，做一些善后工作
        //比如在corePoolSize跟maximumPoolSize之间的woker会进行回收
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre>
<p>这个方法是线程池复用线程的核心代码，注意Worker继承了AbstractQueuedSynchronizer，在执行每个任务前通过lock方法加锁，执行完后通过unlock方法解锁，这种机制用来防止运行中的任务被中断。在执行任务时先尝试获取firstTask，即构造方法传入的Runnable对象，这个任务就是提交的这个本线程第一个需要执行的任务，如果该任务不为空，那么该线程首先就会执行该任务，否则如果这个任务为空，那么就尝试从getTask方法中获取任务队列中的任务进行执行。</p>
<p>下面重点说说getTask方法，getTask()实现跟我们构造参数keepAliveTime存活时间有关。我们都知道keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。</p>
<pre><code>private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;

        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            //根据超时配置有两种方法取出任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
</code></pre>
<p>这个getTask()方法通过一个循环不断轮询任务队列有没有任务到来，根据超时配置有两种方法取出任务方法：</p>
<p>BlockingQueue.poll这种方法会阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。因此实现了线程的退出与回收。<br>
BlockingQueue.take 这种方法会在取到任务前一直阻塞，直到取到任务就执行该任务，因此实现了线程可以一直执行由用户提交的任务。</p>
<p><strong>关闭线程池</strong></p>
<p>关闭线程池一般有两种形式，shutdown()和shutdownNow()</p>
<pre><code>public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        //通过CAS将状态更改为SHUTDOWN，这个时候线程池不接受新任务，但会继续处理队列中的任务
        advanceRunState(SHUTDOWN);
        //中断所有空闲的worker,也就是说除了正在处理任务的worker，其他阻塞在getTask()上的worker
        //都会被中断
        interruptIdleWorkers();
        //执行回调
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    //这个方法不会等待所有的任务处理完成才返回
}
public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        /*
            不同于shutdown()，会转换为STOP状态，不再处理新任务，队列中的任务也不处理，
            而且会中断所有的worker，而不只是空闲的worker
         */
        advanceRunState(STOP);
        interruptWorkers();
        tasks = drainQueue();//将所有的任务从队列中弹出
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}

private List&lt;Runnable&gt; drainQueue() {
    BlockingQueue&lt;Runnable&gt; q = workQueue;
    ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;();
    /*
        将队列中所有的任务remove掉，并添加到taskList中，
        但是有些队列比较特殊，比如说DelayQueue，如果第一个任务还没到过期时间，则不会弹出，
        因此这里通过调用toArray方法，然后再一个一个的remove掉
     */
    q.drainTo(taskList);
    if (!q.isEmpty()) {
        for (Runnable r : q.toArray(new Runnable[0])) {
            if (q.remove(r))
                taskList.add(r);
        }
    }
    return taskList;
}

</code></pre>
<p>可以看到，调用了shutdown()方法后，不会等待所有的任务处理完毕才返回，因此需要调用awaitTermination()来实现。</p>
<pre><code>public boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (;;) {
            //线程池若已经终结了，那么就返回
            if (runStateAtLeast(ctl.get(), TERMINATED))
                return true;
            //若超时了，也返回掉
            if (nanos &lt;= 0)
                return false;
            //阻塞在信号量上，等待线程池终结,但是要注意这个方法可能会因为一些未知原因随时唤醒当前线程，
            //因此需要重试，在tryTerminate()方法中，执行完terminated()回调后，表明线程池已经终结了,
            //然后会通过termination.signalAll()唤醒当前线程
            nanos = termination.awaitNanos(nanos);
        }
    } finally {
        mainLock.unlock();
    }
}

</code></pre>
<h3 id="参考文章">参考文章：</h3>
<p>https://juejin.im/post/5b8f97825188255c6140a50d<br>
https://www.jianshu.com/p/87bff5cc8d8c<br>
https://juejin.im/post/5aeec0106fb9a07ab379574f<br>
https://juejin.im/post/5b8f97825188255c6140a50d<br>
https://www.jianshu.com/p/f62a3f452869<br>
https://itimetraveler.github.io/2018/02/13/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java中synchronized实现原理]]></title>
        <id>https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li</id>
        <link href="https://pianpian315.github.io/post/java-zhong-synchronized-shi-xian-yuan-li">
        </link>
        <updated>2019-11-20T14:15:47.000Z</updated>
        <content type="html"><![CDATA[<p>理解synchronized实现原理，需要弄清楚以下几点：</p>
<h3 id="1-java对象的组成">1、Java对象的组成</h3>
<p>在JVM中，每个Java对象由三部分组成：对象头、实例数据和对齐填充。</p>
<p>Java对象头：普通对象的对象头包括两部分：Mark Word 和 Class Metadata Address （类型指针），如果是数组对象还包括一个额外的Array length数组长度部分。<br>
实例变量：存放类的属性数据信息。<br>
填充数据：虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<p>这里，我们需要重点说说Java对象头。</p>
<h3 id="2-java对象头与锁的关系">2、Java对象头与锁的关系</h3>
<p>前面说过，Java对象头主要结构是由Mark Word 和 Class Metadata Address 组成。</p>
<p>对象头对应的内容在oopDesc里面，在hotspot源码 oop.hpp中对oopDesc进行了定义，定义如下：</p>
<pre><code>class oopDesc {
  friend class VMStructs;

 private:
  volatile markOop  _mark; // 对应Mark Word

  union _metadata {   // 对应Class Metadata Address
    Klass*      _klass;
    narrowKlass _compressed_klass;
  } _metadata;
}
</code></pre>
<p>Mark Word：存储对象自身的运行时数据，如对象的hashCode、锁信息或分代年龄或GC标志等信息。<br>
Class Metadata Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</p>
<p>这里需要重点说到的就是Mark Word，也就是上面的markOop，在Hotspot中，它的定义markOop.hpp文件中，代码如下：</p>
<pre><code>class markOopDesc: public oopDesc {

 private:
  // Conversion
  uintptr_t value() const { return (uintptr_t) this; }

 public:
  // Constants
  enum { age_bits                 = 4,  //分代年龄
         lock_bits                = 2, //锁标识
         biased_lock_bits         = 1, //是否为偏向锁
         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,
         hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits, //对象的hashcode
         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),
         epoch_bits               = 2 //偏向锁的时间戳
  };

...
</code></pre>
<p>从上面我们可以大致的看到Mark Word里面的存储内容，Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，下面以32位虚拟机为例。<br>
<img src="https://pianpian315.github.io/post-images/1574640692885.png" alt=""></p>
<p>可以看到Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，其实围绕这个锁的一系列操作都和Mark word有关系。</p>
<p>在JDK1.6之前，synchronized是一个重量级锁，从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，synchronized进行了优化，引入了 偏向锁和轻量级锁的概念。所以从JDK1.6开始，锁的状态根据竞争激烈程度从低到高分别是:无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。锁的状态会随着锁竞争的情况逐步升级，另外，为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。</p>
<h4 id="偏向锁">偏向锁</h4>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p>
<h4 id="轻量级锁">轻量级锁</h4>
<p>对于锁竞争比较激烈的场合，也就是每次申请锁的线程都是不相同的，这个时候偏向锁失败，此时Mark Word 的结构也变为轻量级锁的结构。引入轻量级锁的目的是在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗。</p>
<h4 id="重量级锁">重量级锁</h4>
<p>如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，重量级锁就是通过对象内部的监视器（monitor）实现。</p>
<p>markOopDesc里面扩展了自己的monitor方法，这个方法返回一个ObjectMonitor指针对象，在hotspot虚拟机中，就是使用这个ObjectMonitor类来实现monitor的。</p>
<pre><code>bool has_monitor() const {
  return ((value() &amp; monitor_value) != 0);
}

ObjectMonitor* monitor() const {
  assert(has_monitor(), &quot;check&quot;);

  // Use xor instead of &amp;~ to provide one extra tag-bit check.
  return (ObjectMonitor*) (value() ^ monitor_value);
}
</code></pre>
<p>在 ObjectMonitor.hpp中，可以看到ObjectMonitor的定义：</p>
<pre><code>class ObjectMonitor {
    ...

    ObjectMonitor() {
    _header       = NULL; //markOop对象头
    _count        = 0;    
    _waiters      = 0,   //等待线程数
    _recursions   = 0;   //重入次数
    _object       = NULL;  
    _owner        = NULL;  //获得ObjectMonitor对象的线程
    _WaitSet      = NULL;  //处于wait状态的线程，会被加入到waitSet
    _WaitSetLock  = 0 ; 
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁BLOCKED状态的线程
    _SpinFreq     = 0 ;   
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ; 
    _previous_owner_tid = 0; //监视器前一个拥有线程的ID
    }
    ...
}
</code></pre>
<p>在这里，我们可以知道每个对象都有一个monitor与之关联，monitor可以理解为一个对象监视器，这个对象监视器作为一个同步工具来记录和确保代码的同步性。</p>
<p>大致流程如下：</p>
<p>oopDesc–&gt;markOopDesc–方法monitor()–&gt;ObjectMonitor–&gt;enter、exit 获取、释放锁</p>
<p>当多个线程同时访问一段同步代码时，首先会进入_EntryList队列中，当某个线程获取到对象的monitor后进入_Owner区域并把monitor中的_owner变量设置为当前线程，同时monitor中的计数器_count加1。即获得对象锁。</p>
<p>若持有monitor的线程调用wait()方法，将释放当前持有的monitor，_owner变量恢复为null，_count自减1，同时该线程进入_WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：<br>
<img src="https://pianpian315.github.io/post-images/1574640708722.png" alt=""></p>
<h3 id="3-synchronized字节码">3、synchronized字节码</h3>
<p>下面从字节码入手，来看看synchronized作为实例锁的两种用法。</p>
<pre><code>public class App {
    public synchronized void test1() {
    }

    public void test2() {
        synchronized (this){
        }
    }

    public static void main( String[] args ){
        System.out.println( &quot;Hello World!&quot; );
    }
}
</code></pre>
<p>通过 javap -v App.class查看字节码。</p>
<pre><code>public synchronized void test1();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED // 同步修饰符
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  this   Lcom/gupaoedu/openclass/App;


  public void test2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter  //监视器进入，获取锁
         4: aload_1
         5: monitorexit  //监视器退出，释放锁
         6: goto          14
         9: astore_2
        10: aload_1
        11: monitorexit
        12: aload_2
        13: athrow
        14: return
</code></pre>
<p>同步块的实现使用monitorenter和monitorexit指令，而同步方法是依靠方法修饰符上的flag ACC_SYNCHRONIZED来完成。其本质就是通过锁对象头中的Mark word来实现的。</p>
<h3 id="参考文献">参考文献：</h3>
<p>https://blog.csdn.net/javazejian/article/details/72828483<br>
https://juejin.im/post/5b90cd7c5188255c877e20c8<br>
https://www.jianshu.com/p/c5058b6fe8e5<br>
https://www.cnblogs.com/dennyzhangdd/p/6734638.html<br>
https://tech.meituan.com/2018/11/15/java-lock.html<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483689&amp;idx=1&amp;sn=4bd727cc4991e54e273e099010c82d3b&amp;chksm=e96eaae7de1923f14db6ab744331c5f3ea1176af0cfd16df598f9e8817f2e4512dae6dd17d16&amp;token=860755966&amp;lang=zh_CN&amp;scene=21#wechat_redirect<br>
https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&amp;mid=2247483699&amp;idx=1&amp;sn=9e51113bbbb3ae94d6b7273f3ee1b00f&amp;chksm=e96eaafdde1923eb6d3f721c902335c54037b503d5a3d7693e30246efa8356c41ea17bcfacc5&amp;token=1402731013&amp;lang=zh_CN#rd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的VSync机制]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-vsync-ji-zhi">
        </link>
        <updated>2019-11-10T06:42:05.000Z</updated>
        <content type="html"><![CDATA[<p>我们知道，UI的显示是一帧一帧的，一次绘制过程，我们称其为一帧，在Flutter中，engine是通过VSync信号不断地触发每一帧的绘制，我们之所以说Flutter可以实现60fps，就是因为一秒钟可以触发60次重绘，那绘制是如何通过VSync信号进行驱动的呢？<br>
<img src="https://pianpian315.github.io/post-images/1573368494773.png" alt=""></p>
<p>VSync可以理解为一种定时中断，系统在每次可以进行绘制的时候都会发送VSync信号，CPU/GPU收到信号后马上处理绘制。所以，在Flutter中，当需要进行渲染绘制的时候，我们就需要监听VSync信号，当有VSync信号产生的时候，就可以绘制操作。<br>
<img src="https://pianpian315.github.io/post-images/1573368549589.png" alt=""></p>
<p>那现在的问题就是如果需要进行绘制操作，如何来监听这个VSync信号呢？我们首先需要通过引擎Engine的ScheduleFrame()方法来注册VSYNC信号回调，这个时候当Vsync信号到来的时候就会收到通知，然后就可以进行渲染绘制操作了。</p>
<p>ScheduleFrame()是Flutter Engine里面的方法，我们在Flutter Framework中如何调用到这个方法了，这个时候上一篇文章讲解的Window就发挥出作用了，在Window中有一个native的scheduleFrame方法，它调用的就是引擎Engine的ScheduleFrame()方法，跟Java中的JNI机制差不多，注册完成之后，当下一个VSync信息到来的时候，Window类中的_handleBeginFrame()和_handleDrawFrame()就会被回调，这样我们就可以收到绘制通知，具体的源码调用过程这里就不展开了，感兴趣的可以参考文章：http://gityuan.com/2019/06/15/flutter_ui_draw/。</p>
<p>下面我们同样举个例子来验证一下这个监听和回调过程：</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onBeginFrame = (Duration rawTimeStamp) {
    print(&quot;onBeginFrame: &quot; + rawTimeStamp.toString());
  };

  window.onDrawFrame = () {
    print(&quot;onDrawFrame&quot;);
  };

  print(&quot;scheduleFrame&quot;);
  window.scheduleFrame();
}
</code></pre>
<p>上面的代码很简单，首先实现了onBeginFrame和onDrawFrame回调，然后调用window的scheduleFrame注册VSync监听。</p>
<p>运行该程序，输出结果如下：</p>
<pre><code>I/flutter ( 4296): scheduleFrame
I/flutter ( 4296): onBeginFrame: 281:12:30.761601
I/flutter ( 4296): onDrawFrame
</code></pre>
<p>其实在Flutter Framework中，UI的渲染就是通过监听这个来触发的，Flutter Framework对其进行了封装，通过一个渲染流水线（Rendering pipline）来进行UI的渲染，具体我们在SchedulerBinding类中的initInstances方法中可以看到。</p>
<pre><code class="language-dart">mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onBeginFrame = _handleBeginFrame;
    window.onDrawFrame = _handleDrawFrame;
    
    // ......
  }

  void _handleBeginFrame(Duration rawTimeStamp) {
    if (_warmUpFrame) {
      assert(!_ignoreNextEngineDrawFrame);
      _ignoreNextEngineDrawFrame = true;
      return;
    }
    handleBeginFrame(rawTimeStamp);
  }

  void _handleDrawFrame() {
    if (_ignoreNextEngineDrawFrame) {
      _ignoreNextEngineDrawFrame = false;
      return;
    }
    handleDrawFrame();
  }
  
  // ......
}
</code></pre>
<p>上面的代码涉及到渲染的整个流水线过程，这里就不进行展开，后面会专门进行分析，这里需要重点理解的是整个Vsync机制，它是UI绘制的发动机，通过它的驱动UI才能不断的进行绘制。</p>
<h3 id="参考文章">参考文章</h3>
<p>https://juejin.im/post/5b7767fef265da43803bdc65<br>
http://gityuan.com/2019/06/15/flutter_ui_draw/<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html<br>
https://www.jianshu.com/p/a9364f778bf8<br>
https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://coolegos.github.io/2017/10/18/Andorid%E4%B8%ADVSync%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter中的Window]]></title>
        <id>https://pianpian315.github.io/post/flutter-zhong-de-window</id>
        <link href="https://pianpian315.github.io/post/flutter-zhong-de-window">
        </link>
        <updated>2019-11-10T06:18:07.000Z</updated>
        <content type="html"><![CDATA[<p>在Flutter中，Window类是Flutter Framework跟宿主系统相连接的接口，宿主系统通过Window类开放了各种各样的回调方法以及native调用接口供Flutter Framework使用。Window类来自库dart:ui，相关源代码在window.dart中，我们来具体看看其代码。</p>
<pre><code class="language-dart">/// The [Window] singleton. This object exposes the size of the display, the
/// core scheduler API, the input event callback, the graphics drawing API, and
/// other such core services.
final Window window = new Window._();
</code></pre>
<p>上面代码是Window实例化的过程，从注释我们可以知道，Window是一个单例对象，它对上层提供屏幕尺寸，调度接口，输入事件回调，图形绘制接口以及其他一些核心服务。正是因为如此，我们才可以通过window来获取底层系统传递过来的各种各样的信息，另外，window也提供了一些native调用，方便上层进行一些系统调用。</p>
<p>下面来具体看看核心代码：</p>
<pre><code class="language-dart">class Window {

  // 当前设备的DPI，即一个逻辑像素显示多少物理像素，数字越大，显示效果就越精细保真。
  // DPI是设备屏幕的固件属性，如Nexus 6的屏幕DPI为3.5 
  double get devicePixelRatio =&gt; _devicePixelRatio;

  // Flutter UI绘制区域的大小
  Size get physicalSize =&gt; _physicalSize;

  // 当前系统默认的语言Locale
  Locale get locale;

  // 当前系统字体缩放比例。  
  double get textScaleFactor =&gt; _textScaleFactor;  

  // 当绘制区域大小改变回调
  VoidCallback get onMetricsChanged =&gt; _onMetricsChanged;  
  // Locale发生变化回调
  VoidCallback get onLocaleChanged =&gt; _onLocaleChanged;
  // 系统字体缩放变化回调
  VoidCallback get onTextScaleFactorChanged =&gt; _onTextScaleFactorChanged;
  // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用
  FrameCallback get onBeginFrame =&gt; _onBeginFrame;
  // 绘制回调  
  VoidCallback get onDrawFrame =&gt; _onDrawFrame;
  // 点击或指针事件回调
  PointerDataPacketCallback get onPointerDataPacket =&gt; _onPointerDataPacket;
  // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用，
  // 此方法会直接调用Flutter engine的Window_scheduleFrame方法
  void scheduleFrame() native 'Window_scheduleFrame';
  // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法
  void render(Scene scene) native 'Window_render';

  // 发送平台消息
  void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) ;
  // 平台通道消息处理回调  
  PlatformMessageCallback get onPlatformMessage =&gt; _onPlatformMessage;

  ... //其它属性及回调

}
</code></pre>
<p>下面我们具体以一个例子来说明上面信息是如何使用的，在我们的应用开发过程中，我们需要响应各种手势事件来实现不同的功能，那么在Flutter中，手势事件是如何产生的呢？从Window中我们可以找到答案，我们看到有一个onPointerDataPacket函数回调，flutter就是通过该方法来接收系统底层传递过来的事件。</p>
<pre><code class="language-dart">import 'dart:ui';

void main() {

  window.onPointerDataPacket = (PointerDataPacket packet) {
    print(packet.data);
  };
}
</code></pre>
<p>上面是一个很简单的程序，就是当有手势事件产生的时候，直接打印事件数组。</p>
<p>运行该程序，当我们点击屏幕的时候，打印结果如下：</p>
<pre><code>I/flutter: [PointerData(x: 601.0, y: 565.0)]
I/flutter: [PointerData(x: 600.0, y: 565.0)]
I/flutter: [PointerData(x: 599.0, y: 566.0)]
I/flutter: [PointerData(x: 598.0, y: 568.0)]
I/flutter: [PointerData(x: 596.0, y: 572.0)]
</code></pre>
<p>上面的数据就是事件的原始数据，在Flutter中，Flutter Framework会对其进行封装处理和分发，最终才会被对应的组件消费，具体我们可以在GestureBinding类的initInstances方法中看到。</p>
<pre><code class="language-dart">mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    window.onPointerDataPacket = _handlePointerDataPacket;
  }

    void _handlePointerDataPacket(ui.PointerDataPacket packet) {
    // We convert pointer data to logical pixels so that e.g. the touch slop can be
    // defined in a device-independent manner.
    _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, window.devicePixelRatio));
    if (!locked)
      _flushPointerEventQueue();
  }

    void _flushPointerEventQueue() {
    assert(!locked);
    while (_pendingPointerEvents.isNotEmpty)
      _handlePointerEvent(_pendingPointerEvents.removeFirst());
  }

  // ......
}
</code></pre>
<p>这里暂时进行深入，后续有机会会专门进行介绍。</p>
<p>不仅只有事件依赖于Window，从Window源码中我们可以很多东西都依赖于它，所以，学习Flutter源码的第一步就是弄清楚Window的作用。从这篇文章，我们可以看到Window是Flutter应用运行的纽带，它确保了Flutter Framework跟Engine之间的通信，如果没有Window这些接口的支撑，Framework只是一个没有灵魂的肉体。其实我们自己完全可以基于Window搭建一套自己的框架来取代Flutter Framework层。</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://juejin.im/post/5c7cd2f4e51d4537b05b0974<br>
https://mp.weixin.qq.com/s/ncViI0KGikPUIZ7BlEHGOA<br>
https://book.flutterchina.club/chapter14/flutter_app_startup.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenJDK源码下载]]></title>
        <id>https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai</id>
        <link href="https://pianpian315.github.io/post/openjdk-yuan-ma-xia-zai">
        </link>
        <updated>2019-09-29T01:25:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-源码下载">一、源码下载</h2>
<h3 id="1-安装mercurial版本控制">1、安装mercurial版本控制</h3>
<p>在MAC系统中，使用下面命令</p>
<pre><code>$ brew install mercurial
</code></pre>
<p>在Linux系统中，使用下面命令</p>
<pre><code>$ sudo apt-get install mercurial
</code></pre>
<p>mercurial安装完毕后，可以通过hg命令来下载源码，使用方式和git、svn类似。</p>
<h3 id="2-下载openjdk源码">2、下载OpenJDK源码</h3>
<pre><code>$ hg clone http://hg.openjdk.java.net/jdk8/jdk8 jdk8
</code></pre>
<p>你可以看到clone下来的代码很少，那是因为OpenJDK将不同类型的source文件放在了不同的子仓库，你可以进入OpenJDK的目录，执行get_source.sh文件即可。</p>
<pre><code>$ cd jdk8
$ chmod +x get_source.sh
$ ./get_source.sh
</code></pre>
<h3 id="3-配置jdk可选">3、配置JDK（可选）</h3>
<pre><code>$ bash configure
</code></pre>
<h3 id="4-构建编译">4、构建编译</h3>
<pre><code>$ make clean images
</code></pre>
<p>或者</p>
<pre><code>make clean images LOG=debug // to display DEBUG information
</code></pre>
<p>你也可以单独对某个模块进行编译构建</p>
<pre><code>$ make jdk
$ make hotspot
$ make test
</code></pre>
<h2 id="二-源码基本说明">二、源码基本说明</h2>
<p>— corba：不流行的多语言、分布式通讯接口<br>
— hotspot：Java 虚拟机<br>
— jaxp：XML 处理<br>
— jaxws：一组 XML web services 的 Java API<br>
— langtools：Java 语言工具<br>
— nashorn：JVM 上的 JavaScript 运行时<br>
— jdk：java 开发工具包<br>
jdk是我们研究源码经常会用到的，里面包含：<br>
— 针对操作系统的部分<br>
— share：与平台无关的实现</p>
<h3 id="参考文章">参考文章：</h3>
<p>https://download.java.net/openjdk/jdk8<br>
https://www.jianshu.com/p/fd26b158dede<br>
https://adoptopenjdk.gitbooks.io/adoptopenjdk-getting-started-kit/en/binaries/build_openjdk_8.html<br>
https://hunterzhao.io/post/2018/01/29/compile-openjdk10-source-code-on-mac/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目团队管理]]></title>
        <id>https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-xi-xiang-mu-tuan-dui-guan-li">
        </link>
        <updated>2019-09-19T15:58:25.000Z</updated>
        <content type="html"><![CDATA[<p>下面结合自身的项目经验，说说项目团队管理。</p>
<h4 id="1-新人分配导师">1、新人分配导师</h4>
<p>为新人工分配一个导师，由导师带领新人熟悉业务、工作流程以及公司环境。</p>
<h4 id="2-新人串讲">2、新人串讲</h4>
<p>新人进入团队之后，需要对自己所负责的模块进行串讲，并且由组内其他成为来进行提问打分，不通过的话就继续熟悉项目，然后继续串讲，直到通过为止。</p>
<h4 id="3-周报周会">3、周报（周会）</h4>
<p>项目组内所有成员每周都需要对自己工作内容进行总结并且写成周报，每周会有一次周会来进行工作内容汇总和讨论。</p>
<h4 id="4-技术分享">4、技术分享</h4>
<p>每周进行一次技术分享，由组内成员自发报名，分享内容包括技术调研，工作技术输出等等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目分支管理]]></title>
        <id>https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li</id>
        <link href="https://pianpian315.github.io/post/qian-tan-xiang-mu-fen-zhi-guan-li">
        </link>
        <updated>2019-09-18T13:55:17.000Z</updated>
        <content type="html"><![CDATA[<p>分支的管理对于项目的开发非常重要，下面结合自身项目经验说说分支的管理。</p>
<p>项目的代码分支主要有以下几条线：</p>
<p>(1) feature-v*：feature分支，用于各版本的feature迭代开发</p>
<p>(2) apk-dev：开发分支，用于编译线下测试版本（debug版本）</p>
<p>(3) apk-rel：发布分支，用于编译线上发布版本（release版本）</p>
<p>每一个版本建立一个专门的feature分支（比如，feature-v1, feature-v2, feature-v3......）。在一个版本开发完毕后，把feature分支merge到apk-dev分支；下一个版本以最新的apk-dev为base建立新的feature分支；apk-dev分支FC测试通过后将apk-dev分支merge到apk-rel分支上，然后apk-rel分支RC测试通过后即可进行上线发布。</p>
<p>feature-v* --&gt; apk-dev --&gt; apk-rel</p>
<p>另外附上一个参考链接：<br>
http://www.ruanyifeng.com/blog/2012/07/git.html</p>
]]></content>
    </entry>
</feed>